<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Art Gallery</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Damion&family=Doto:wght@100..900&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: "Inter", sans-serif;
            background-color: #1a202c;
            color: #00ffff;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background-color: rgba(0,0,0,0.5);
            z-index: 10; /* Ensures the blocker is on top of the canvas */
        }
        #instructions {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 1.5rem;
            cursor: pointer;
            color: white;
        }
        #menu-container {
            position: absolute;
            top: 10px;
            left: 10px;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
            /* Initially hidden, controlled by PointerLockControls */
            display: none;
            flex-direction: column;
            clip-path: polygon(1rem 0, 100% 0, 100% 100%, 0 100%, 0 1rem);
            background-color: rgba(30, 41, 59, 0.85);
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
            border-radius: 0.5rem;
            padding: 1rem;
            z-index: 20; /* Ensures the menu is on top of the blocker */
        }
        .menu-title {
            font-size: 1.875rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            text-align: center;
            color: #00aaaa;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        .menu-item {
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            background-color: rgba(51, 65, 85, 0.8);
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            border: 2px solid rgba(0, 187, 255, 0.5);
            font-weight: 500;
            clip-path: polygon(1rem 0, 100% 0, 100% 100%, 0 100%, 0 1rem);
        }
        .menu-item:hover {
            background-color: rgba(71, 85, 105, 0.9);
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.15);
        }
        .subtitle {
            font-size: 0.875rem;
            color: #00bbff;
            margin-top: 0.25rem;
            font-style: italic;
        }
        #menu-columns-wrapper {
            display: flex;
            flex-direction: row;
            align-items: stretch;
            flex-grow: 1;
            overflow: hidden;
        }
        #artwork-info-popup {
            position: absolute;
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 8px;
            border-radius: 5px;
            display: none;
            pointer-events: none;
            z-index: 999;
            white-space: nowrap; /* Prevent text from wrapping */
            transform: translateX(-50%); /* Center horizontally relative to its left edge */
        }

        /* Styles for the new artwork modal */
        #artwork-modal {
            display: none; /* Hidden by default */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8); /* Semi-transparent black background */
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Ensure it's on top of everything */
        }

        #artwork-modal-content {
            position: relative;
            max-width: 90%;
            max-height: 90%;
            background-color: #333; /* Dark background for the modal content */
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5); /* Shadow for depth */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #modal-artwork-img {
            max-width: 100%;
            max-height: 80vh; /* Limit image height to 80% of viewport height */
            display: block;
            margin: auto;
            object-fit: contain; /* Ensure the entire image fits within its bounds */
        }

        #modal-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 5px;
            transition: background-color 0.2s ease;
        }

        #modal-close-btn:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        /* Styles for the back wall popup */
        #back-wall-popup {
            position: fixed;
            left: 50%;
            top: 30%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #0088ff;
            border-radius: 15px;
            color: white;
            padding: 32px 32px 24px 32px;
            text-align: center;
            font-size: 1.3rem;
            z-index: 2000;
            display: none;
        }
    </style>
</head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-FWN6NL8B16"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-FWN6NL8B16');
</script>
<body>
    <div style="position: absolute; top: 10px; left: 10px; z-index: 999;">
        <a href="../index.html" style="color: white; text-decoration: none; background-color: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 5px;">Back to Main</a>
    </div>
    <div id="threejs-container"></div>

    <!-- Blocker and Instructions for Pointer Lock -->
    <div id="blocker">
        <div id="instructions">
            <p style="font-size:36px">Click to play</p>
            <p>Move: W, A, S, D<br/>Jump: SPACE<br/>Look: MOUSE<br/>Menu: ESC</p>
        </div>
    </div>

    <!-- Menu Container -->
    <div id="menu-container">
        <div class="menu-title">Art Gallery Menu</div>
        <div id="menu-columns-wrapper"></div>
    </div>

    <!-- Artwork Info Popup -->
    <div id="artwork-info-popup"></div>

    <!-- Artwork Modal -->
    <div id="artwork-modal">
        <div id="artwork-modal-content">
            <img id="modal-artwork-img" src="" alt="Artwork">
            <button id="modal-close-btn">&times;</button>
        </div>
    </div>

    <!-- Back Wall Popup (for redirect notice) -->
    <div id="back-wall-popup"></div>

    <script>
        // --- PointerLockControls Class (embedded) ---
        // This avoids needing to manage separate files or module imports
        var PointerLockControls = function ( camera, domElement ) {

            if ( domElement === undefined ) {
                console.warn( 'THREE.PointerLockControls: The second parameter "domElement" is now mandatory.' );
                domElement = document.body;
            }

            this.domElement = domElement;
            this.isLocked = false;

            // Set to constrain the pitch of the camera
            // Range is 0 to Math.PI radians
            this.minPolarAngle = 0; // radians
            this.maxPolarAngle = Math.PI; // radians

            var scope = this;
            var euler = new THREE.Euler( 0, 0, 0, 'YXZ' );
            var PI_2 = Math.PI / 2;
            var vec = new THREE.Vector3();

            function onMouseMove( event ) {
                if ( scope.isLocked === false ) return;
                var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                euler.setFromQuaternion( camera.quaternion );
                euler.y -= movementX * 0.002;
                euler.x -= movementY * 0.002;
                euler.x = Math.max( PI_2 - scope.maxPolarAngle, Math.min( PI_2 - scope.minPolarAngle, euler.x ) );
                camera.quaternion.setFromEuler( euler );
                scope.dispatchEvent( { type: 'change' } );
            }

            function onPointerlockChange() {
                if ( document.pointerLockElement === scope.domElement ) {
                    scope.dispatchEvent( { type: 'lock' } );
                    scope.isLocked = true;
                } else {
                    scope.dispatchEvent( { type: 'unlock' } );
                    scope.isLocked = false;
                }
            }

            function onPointerlockError() {
                console.error( 'THREE.PointerLockControls: Unable to use Pointer Lock API' );
            }

            this.connect = function () {
                document.addEventListener( 'mousemove', onMouseMove, false );
                document.addEventListener( 'pointerlockchange', onPointerlockChange, false );
                document.addEventListener( 'pointerlockerror', onPointerlockError, false );
            };

            this.disconnect = function () {
                document.removeEventListener( 'mousemove', onMouseMove, false );
                document.removeEventListener( 'pointerlockchange', onPointerlockChange, false );
                document.removeEventListener( 'pointerlockerror', onPointerlockError, false );
            };

            this.dispose = function () {
                this.disconnect();
            };

            this.getObject = function () { // retaining this method for backward compatibility
                return camera;
            };

            this.getDirection = function () {
                var direction = new THREE.Vector3( 0, 0, - 1 );
                return function ( v ) {
                    return v.copy( direction ).applyQuaternion( camera.quaternion );
                };
            }();

            this.moveForward = function ( distance ) {
                vec.setFromMatrixColumn( camera.matrix, 0 );
                vec.crossVectors( camera.up, vec );
                camera.position.addScaledVector( vec, distance );
            };

            this.moveRight = function ( distance ) {
                vec.setFromMatrixColumn( camera.matrix, 0 );
                camera.position.addScaledVector( vec, distance );
            };

            this.lock = function () {
                this.domElement.requestPointerLock();
            };

            this.unlock = function () {
                document.exitPointerLock();
            };

            this.connect();
        };
        PointerLockControls.prototype = Object.create( THREE.EventDispatcher.prototype );
        PointerLockControls.prototype.constructor = PointerLockControls;
        
        // --- Main Application Logic ---
        let scene, camera, renderer, controls;
        let raycaster, menuData;
        
        // FPS Player state
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        const playerVelocity = new THREE.Vector3();
        const playerSpeed = 6.0; // Match Mall.html
        const playerHeight = 1.75;
        let prevTime = performance.now();
        let artworkInfoPopup; // Declare globally
        let currentHoveredArtwork = null; // Declare globally
        let wallThickness, roomSize; // Declare globally
        let interactiveArtworks = []; // To store artwork meshes for raycasting
        const objects = []; // For collision detection

        let digitalSwitchingImagePlane; // Declare globally
        let currentDigitalImageIndex = 0; // Declare globally
        let digitalArtworkInfoMesh; // New: Three.js mesh for digital art info

        // New global variables for shuffled playback
        let shuffledDigitalArtIndices = [];
        let currentShuffledIndex = 0;

        // Global variables for digital screen dimensions
        const digitalScreenWidth = 2.667;
        const digitalScreenHeight = 2.0;

        // New global variables for scrolling text and image flipping control
        let textCanvas, textCanvasContext;
        let currentInfoText = "";
        let textScrollOffset = 0;
        const textScrollSpeed = 0.5; // units per second (adjust as needed)
        let textWidth = 0; // Actual pixel width of the text
        let isTextScrolling = false; // Flag to indicate if text is currently scrolling
        let lastScrollFinishTime = 0; // Time when the text finished scrolling
        const delayAfterScroll = 2000; // 2 seconds delay after text finishes scrolling before next image (in ms)

        const menuContainer = document.getElementById('menu-container');
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');

        // Get references to artwork modal elements
        const artworkModal = document.getElementById('artwork-modal');
        const modalArtworkImg = document.getElementById('modal-artwork-img');
        const modalCloseBtn = document.getElementById('modal-close-btn');

        // Dummy data for artworks. In a real application, these would be loaded dynamically from a server.
        // Paths are relative to the current HTML file.
        // To fix texture loading errors in the browser, placeholder images are used.
        // In a deployed application, you would replace these with actual image URLs hosted on your server.
        const artworks = {
            Paintings: [
                { name: "Bassist", path: "Paintings/Bassist.jpg" },
                { name: "Blue Bass", path: "Paintings/BlueBass.jpg" },
                { name: "Buskers", dimensions: "1.2m x 1m", path: "Paintings/buskers_1_2mx1m.jpg" },
                { name: "Funky Duel", path: "Paintings/funky Duel.jpg" },
                { name: "Jazz Trio", path: "Paintings/Jazz Trio.jpg" },
                { name: "Sax Player", path: "Paintings/saxplayer2016.jpg" },
                { name: "Sunflower", path: "Paintings/sonflower_acrylic.jpg" },
                { name: "Summer Blue Butterfly", path: "Paintings/Summer Blue Butterfly.jpg" }
            ],
            Digital: [
                { name: "• Bass Still", path: "Digital/Bass Still.jpg", artist: "Gerhard", year: 2006, medium: "Pov-Ray Render" },
                { name: "• Buskers", path: "Digital/Buskers.jpg", artist: "Gerhard", year: 2013, medium: "Pov-Ray Render" },
                { name: "• Funky Shadows", path: "Digital/funky_shadows.jpg", artist: "Gerhard", year: 2007, medium: "Pov-Ray Render" },
                { name: "• Fuzion Paint", path: "Digital/Fuzion paint.png", artist: "Gerhard", year: 2015, medium: "Pov-Ray Render" },
                { name: "• Bass", path: "Digital/GO_bass.jpg", artist: "Gerhard", year: 2004, medium: "Pov-Ray Render" },
                { name: "• Jazz Funk", path: "Digital/jazz_funk.jpg", artist: "Gerhard", year: 2007, medium: "Pov-Ray Render" },
                { name: "• Sunny in the Shade", path: "Digital/Sunny in the Shade.jpg", artist: "Gerhard", year: 2012, medium: "Pov-Ray Render" },
                { name: "• SuperStars", path: "Digital/superstars abstract.png", artist: "Gerhard", year: 2013, medium: "Pov-Ray Render" },
                { name: "• The abstract buskers", path: "Digital/The abstract buskers.jpg", artist: "Gerhard", year: 2013, medium: "Pov-Ray Render" },
                { name: "• The Colours of Music", path: "Digital/the Colours of Music.png", artist: "Gerhard", year: 2013, medium: "Pov-Ray Render" }
            ]
        };

        init();
        animate();

        function parseMenuXML(xmlString) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, "application/xml");
            const menuElement = xmlDoc.querySelector('menu');
            function parseItem(element) {
                const item = { name: element.getAttribute('name'), link: element.getAttribute('link') || null, subtitle: '', children: [] };
                const subtitleElement = element.querySelector(':scope > subtitle');
                if (subtitleElement) item.subtitle = subtitleElement.textContent.trim();
                const childItemElements = element.querySelectorAll(':scope > item');
                childItemElements.forEach(childElement => item.children.push(parseItem(childElement)));
                return item;
            }
            const items = menuElement.querySelectorAll(':scope > item');
            const parsedMenu = { name: "Root", subtitle: "", children: [] };
            items.forEach(itemElement => parsedMenu.children.push(parseItem(itemElement)));
            return parsedMenu;
        }

        function addCeilingLights() {
            const lightSpacing = 4; // Distance between lights
            const lightIntensity = 0.3; // Adjust intensity to not overpower spotlights
            const lightColor = 0xffffff; // White light
            const lightHeight = 2.9; // Just below the ceiling

            // Calculate the number of lights along each axis
            const numLightsX = Math.floor(roomSize / lightSpacing);
            const numLightsZ = Math.floor(roomSize / lightSpacing);

            for (let i = 0; i <= numLightsX; i++) {
                for (let j = 0; j <= numLightsZ; j++) {
                    const x = -roomSize / 2 + i * lightSpacing;
                    const z = -roomSize / 2 + j * lightSpacing;

                    const pointLight = new THREE.PointLight(lightColor, lightIntensity, lightSpacing * 2);
                    pointLight.position.set(x, lightHeight, z);
                    scene.add(pointLight);
                }
            }
        }

        function init() {
            // Get the artwork info popup element
            artworkInfoPopup = document.getElementById('artwork-info-popup');


            // Create a simple menu structure for the art gallery
            // This is a simplified version compared to the original XML parsing
            menuData = {
                name: "Root",
                subtitle: "",
                children: [
                    {
                        name: "Paintings",
                        subtitle: "Traditional Acrylic Artworks",
                        children: artworks.Paintings.map(art => ({
                            name: art.name,
                            subtitle: art.dimensions,
                            link: art.path // Could potentially open a larger view of the artwork
                        }))
                    },
                    {
                        name: "Back to Main Page",
                        subtitle: "Return to the main mall area",
                        link: "../index.html"
                    }
                ]
            };


            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 1.75; // Player height

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222233);
            scene.fog = new THREE.Fog(0x222233, 0, 75);

            // Ambient light to provide some fill light, but much dimmer
            const light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.2);
            light.position.set(0.5, 1, 0.75);
            scene.add(light);

            

            // Setup pointer lock controls
            controls = new PointerLockControls(camera, document.body);
            instructions.addEventListener('click', function () { controls.lock(); });
            controls.addEventListener('lock', () => { instructions.style.display = 'none'; blocker.style.display = 'none'; menuContainer.style.display = 'none'; });
            controls.addEventListener('unlock', () => { blocker.style.display = 'block'; instructions.style.display = 'flex'; menuContainer.style.display = 'flex'; renderMenuColumns([]); });
            scene.add(controls.getObject());

            // Keyboard controls
            const onKeyDown = function (event) {
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = true; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                    case 'ArrowRight': case 'KeyD': moveRight = true; break;
                    case 'Space': /* if (canJump === true) velocity.y += 1; canJump = false; */ break; // Removed jump logic as per Mall.html
                    case 'Escape': // Handle Escape key
                        if (artworkModal.style.display === 'flex') {
                            hideArtworkModal(); // If artwork modal is open, close it first
                        } else if (menuContainer.style.display === 'flex') {
                            // If menu is already open, navigate back to main page
                            window.location.href = '../index.html';
                        }
                        break;
                }
            };
            const onKeyUp = function (event) {
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = false; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                    case 'ArrowRight': case 'KeyD': moveRight = false; break;
                }
            };
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 10);
            
            // Floor (Checkerboard with textures from Mall.html)
            const textureLoader = new THREE.TextureLoader();
            const marbleTextureA = textureLoader.load('images/MarbleWhiteA.png');
            const marbleTextureB = textureLoader.load('images/MarbleWhiteB.png');

            // Set wrapping mode for textures to repeat
            marbleTextureA.wrapS = THREE.RepeatWrapping;
            marbleTextureA.wrapT = THREE.RepeatWrapping;
            marbleTextureB.wrapS = THREE.RepeatWrapping;
            marbleTextureB.wrapT = THREE.RepeatWrapping;

            const tileSize = 4; 
            const floorWidth = 10;
            const floorDepth = 10;

            const tileGeometry = new THREE.PlaneGeometry(tileSize, tileSize);

            function getRandomRotation() {
                return Math.PI / 2 * Math.floor(Math.random() * 4);
            }

            for (let x = -floorWidth / 2; x < floorWidth / 2; x += tileSize) {
                for (let z = -floorDepth / 2; z < floorDepth / 2; z += tileSize) {
                    const tileXIndex = Math.floor((x + floorWidth / 2) / tileSize);
                    const tileZIndex = Math.floor((z + floorDepth / 2) / tileSize);
                    const useTextureA = (tileXIndex + tileZIndex) % 2 === 0;

                    const material = new THREE.MeshStandardMaterial({
                        map: useTextureA ? marbleTextureA : marbleTextureB,
                        metalness: 0.0,
                        roughness: 0.1,
                        side: THREE.DoubleSide,
                    });

                    const tile = new THREE.Mesh(tileGeometry, material);
                    tile.rotation.x = -Math.PI / 2;
                    tile.rotation.z = getRandomRotation();
                    tile.position.set(x + tileSize / 2, 0, z + tileSize / 2); 
                    tile.receiveShadow = true;
                    scene.add(tile);
                    objects.push(tile);
                }
            }

            // Ceiling
            const ceilingGeometry = new THREE.PlaneGeometry(10, 10);
            const ceilingMaterial = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.position.y = 3; // wallHeight
            ceiling.rotation.x = Math.PI / 2;
            scene.add(ceiling);

            // Walls
            const wallHeight = 3;
            wallThickness = 0.1; // Initialize global
            roomSize = 10; // Initialize global

            // Wall Materials (Marble)
            const blueMarbleTextures = [
                'images/BlueMarble(1).png',
                'images/BlueMarble(2).png',
                'images/BlueMarble(3).png',
                'images/BlueMarble(4).png',
                'images/BlueMarble(5).png'
            ];

            function loadAllTextures(paths, callback) {
                let loaded = 0;
                const textures = [];
                paths.forEach((path, i) => {
                    textureLoader.load(path, function(tex) {
                        textures[i] = tex;
                        loaded++;
                        if (loaded === paths.length) callback(textures);
                    });
                });
            }

            function getRandomWallMaterialsForSet(count, loadedTextures) {
                const indices = [];
                const available = [...Array(loadedTextures.length).keys()];
                for (let i = 0; i < count; i++) {
                    const pick = Math.floor(Math.random() * available.length);
                    indices.push(available.splice(pick, 1)[0]);
                }
                return indices.map(idx => {
                    const origTex = loadedTextures[idx];
                    if (!origTex.image) return new THREE.MeshStandardMaterial({ color: 0x222244 });
                    const texClone = new THREE.Texture(origTex.image);
                    texClone.needsUpdate = true;
                    const rotations = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2];
                    texClone.rotation = rotations[Math.floor(Math.random() * rotations.length)];
                    texClone.center.set(0.5, 0.5);
                    return new THREE.MeshStandardMaterial({
                        map: texClone,
                        metalness: 0.1,
                        roughness: 0.4,
                        side: THREE.DoubleSide
                    });
                });
            }

            // Helper to create a wall from 4 segments
            function createWallSegments({
                start, // Vector3 start position (center of first segment)
                dir,   // Vector3 direction to step for each segment
                segmentWidth, // width of each segment
                wallHeight,
                wallThickness,
                rotation, // Euler rotation for each segment
                loadedTextures
            }) {
                const materials = getRandomWallMaterialsForSet(4, loadedTextures);
                for (let i = 0; i < 4; i++) {
                    // Use PlaneGeometry for correct texture mapping
                    const segmentGeo = new THREE.PlaneGeometry(segmentWidth, wallHeight);
                    const segment = new THREE.Mesh(segmentGeo, materials[i]);
                    segment.receiveShadow = true; // Allow walls to receive shadows
                    // Position the plane so its center is at the correct spot
                    segment.position.copy(start).add(dir.clone().multiplyScalar(i));
                    segment.rotation.copy(rotation);
                    scene.add(segment);
                    objects.push(segment);
                }
            }

            loadAllTextures(blueMarbleTextures, function(loadedTextures) {
                const segmentCount = 4;
                const segmentWidth = roomSize / segmentCount;
                const halfRoom = roomSize / 2;
                const halfSeg = segmentWidth / 2;
                // Back wall (Z = -halfRoom)
                createWallSegments({
                    start: new THREE.Vector3(-halfRoom + halfSeg, wallHeight / 2, -halfRoom),
                    dir: new THREE.Vector3(segmentWidth, 0, 0),
                    segmentWidth,
                    wallHeight,
                    wallThickness,
                    rotation: new THREE.Euler(0, Math.PI, 0),
                    loadedTextures
                });
                // Front wall (Z = +halfRoom)
                createWallSegments({
                    start: new THREE.Vector3(-halfRoom + halfSeg, wallHeight / 2, halfRoom),
                    dir: new THREE.Vector3(segmentWidth, 0, 0),
                    segmentWidth,
                    wallHeight,
                    wallThickness,
                    rotation: new THREE.Euler(0, 0, 0),
                    loadedTextures
                });
                // Left wall (X = -halfRoom)
                createWallSegments({
                    start: new THREE.Vector3(-halfRoom, wallHeight / 2, -halfRoom + halfSeg),
                    dir: new THREE.Vector3(0, 0, segmentWidth),
                    segmentWidth,
                    wallHeight,
                    wallThickness,
                    rotation: new THREE.Euler(0, Math.PI / 2, 0),
                    loadedTextures
                });
                // Right wall (X = +halfRoom)
                createWallSegments({
                    start: new THREE.Vector3(halfRoom, wallHeight / 2, -halfRoom + halfSeg),
                    dir: new THREE.Vector3(0, 0, segmentWidth),
                    segmentWidth,
                    wallHeight,
                    wallThickness,
                    rotation: new THREE.Euler(0, -Math.PI / 2, 0),
                    loadedTextures
                });
            });

            // Pillars at the back of the room
            const pillarTexture = textureLoader.load('images/Marble2.png');
            pillarTexture.wrapS = THREE.RepeatWrapping;
            pillarTexture.wrapT = THREE.RepeatWrapping;
            pillarTexture.repeat.set(1,1); // Adjust tiling to look good

            const pillarMaterial = new THREE.MeshStandardMaterial({
                map: pillarTexture,
                metalness: 0.1,
                roughness: 0.2
            });
            const pillarRadius = 0.25;
            const pillarHeight = wallHeight;
            const pillarGeometry = new THREE.CylinderGeometry(pillarRadius, pillarRadius, pillarHeight, 32);

            const pillar1 = new THREE.Mesh(pillarGeometry, pillarMaterial);
            pillar1.position.set(-3, pillarHeight / 2, -roomSize / 2 + pillarRadius);
            pillar1.rotation.y = Math.PI / 2; // Rotate to hide seam toward the wall
            pillar1.castShadow = true;
            scene.add(pillar1);
            objects.push(pillar1);

            const pillar2 = new THREE.Mesh(pillarGeometry, pillarMaterial);
            pillar2.position.set(3, pillarHeight / 2, -roomSize / 2 + pillarRadius);
            pillar2.rotation.y = Math.PI / 2; // Rotate to hide seam toward the wall
            pillar2.castShadow = true;
            scene.add(pillar2);
            objects.push(pillar2);

            // Digital Artwork Screen (Switching Image)
            const digitalImagePaths = artworks.Digital.map(art => art.path);

            // Remove any previous digital art screen (only use digitalSwitchingImagePlane)
            if (typeof digitalSwitchingImagePlane !== 'undefined' && digitalSwitchingImagePlane) {
                scene.remove(digitalSwitchingImagePlane);
                digitalSwitchingImagePlane = undefined;
            }

            // Create the switching image plane (2.667 x 2.0 units)
            const digitalSwitchingImageMaterial = new THREE.MeshBasicMaterial({
                map: new THREE.TextureLoader().load(digitalImagePaths[0]),
                side: THREE.DoubleSide
            });
            const digitalSwitchingImageGeometry = new THREE.PlaneGeometry(digitalScreenWidth, digitalScreenHeight);
            digitalSwitchingImagePlane = new THREE.Mesh(digitalSwitchingImageGeometry, digitalSwitchingImageMaterial);
            digitalSwitchingImagePlane.position.set(0, pillarHeight / 2, -roomSize / 2 + pillarRadius + 0.05);
            scene.add(digitalSwitchingImagePlane);

            // Add black box behind the digital screen (monitor frame)
            const monitorFrameGeometry = new THREE.PlaneGeometry(digitalScreenWidth + 0.01, digitalScreenHeight + 0.01);
            const monitorFrameMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const monitorFrame = new THREE.Mesh(monitorFrameGeometry, monitorFrameMaterial);
            monitorFrame.position.copy(digitalSwitchingImagePlane.position);
            monitorFrame.position.z -= 0.011; // Slightly behind the screen
            scene.add(monitorFrame);

            // NEW: Digital Artwork Info Text as a Three.js object
            // Create a canvas for the text texture
            textCanvas = document.createElement('canvas'); // Global variable
            textCanvasContext = textCanvas.getContext('2d'); // Global variable
            textCanvas.width = 1024; // Larger resolution for better text quality
            textCanvas.height = 128; // Adjust height as needed for text

            const textTexture = new THREE.CanvasTexture(textCanvas);
            const textMaterial = new THREE.MeshBasicMaterial({ map: textTexture, transparent: true, side: THREE.DoubleSide });
            const textGeometry = new THREE.PlaneGeometry(digitalScreenWidth, 0.3); // Adjust height to fit above monitor
            digitalArtworkInfoMesh = new THREE.Mesh(textGeometry, textMaterial);

            // Position the info mesh just above the monitor screen
            digitalArtworkInfoMesh.position.set(
                digitalSwitchingImagePlane.position.x,
                digitalSwitchingImagePlane.position.y + digitalScreenHeight / 2 + 0.2, // Above the screen
                digitalSwitchingImagePlane.position.z
            );
            scene.add(digitalArtworkInfoMesh);

            // Initial setup for digital artwork info and scrolling
            shuffleDigitalArtworks(); // Create the first shuffled list
            const initialArtworkIndex = shuffledDigitalArtIndices[currentShuffledIndex];
            updateDigitalSwitchingImage(initialArtworkIndex); // Load the first artwork
            // Removed setInterval for digital artwork flipping, now controlled in animate()

            // Function to create and position artworks
            function createArtwork(x, y, z, rotationY, type, art) {
                if (!art) return;

                const loader = new THREE.TextureLoader();
                loader.load(art.path, function (texture) {
                    const artworkGroup = new THREE.Group();

                    // Sizing and thickness logic from Mall.html
                    const aspect = texture.image.width / texture.image.height;
                    let maxSide = 1.5; // Default max size for wall art from Mall.html
                    if (art.name === "Jazz Trio") { // Special case from Mall.html
                        maxSide = 2.0;
                    }
                    let artworkWidth, artworkHeight;
                    if (aspect >= 1) { // Landscape or square
                        artworkWidth = maxSide;
                        artworkHeight = maxSide / aspect;
                    } else { // Portrait
                        artworkHeight = maxSide;
                        artworkWidth = maxSide * aspect;
                    }

                    // Frame with thickness
                    const frameDepth = 0.04;
                    const frameGeo = new THREE.BoxGeometry(artworkWidth, artworkHeight, frameDepth);
                    const frameMat = new THREE.MeshStandardMaterial({ color: 0x1a202c }); // Dark frame to match background
                    const frameMesh = new THREE.Mesh(frameGeo, frameMat);
                    frameMesh.castShadow = true;
                    frameMesh.receiveShadow = true;
                    
                    // The artwork plane itself
                    const artGeo = new THREE.PlaneGeometry(artworkWidth, artworkHeight);
                    const artMat = new THREE.MeshBasicMaterial({ map: texture }); // Using BasicMaterial as in original Art.html
                    const artMesh = new THREE.Mesh(artGeo, artMat);
                    artMesh.position.z = frameDepth / 2 + 0.001; // Position slightly in front of the frame

                    // Add frame and art to the group
                    artworkGroup.add(frameMesh);
                    artworkGroup.add(artMesh);

                    // Create and position the gold plaque below the painting
                    const plaqueWidth = 0.7; // Fixed width for the plaque
                    const plaqueHeight = 0.12; // Fixed height for the plaque
                    const plaqueDepth = 0.02; // Thin plaque

                    const plaqueGeometry = new THREE.BoxGeometry(plaqueWidth, plaqueHeight, plaqueDepth);
                    const plaqueMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.5, roughness: 0.3 }); // Gold color

                    const plaqueMesh = new THREE.Mesh(plaqueGeometry, plaqueMaterial);
                    plaqueMesh.castShadow = true;
                    plaqueMesh.receiveShadow = false;

                    // Position plaque below the artwork
                    plaqueMesh.rotation.x = - Math.PI / 20; // Rotate plaque to face viewer
                    plaqueMesh.position.y = -artworkHeight / 2 - plaqueHeight / 2 - 0.1; // Below artwork, with a small gap
                    plaqueMesh.position.z = frameDepth / 2; //  + 0.001; // Same Z as artwork for alignment

                    artworkGroup.add(plaqueMesh); // Add plaque to the artwork group

                    // Create text for the plaque
                    const plaqueTextCanvas = document.createElement('canvas');
                    const plaqueTextContext = plaqueTextCanvas.getContext('2d');
                    plaqueTextCanvas.width = 512; // High resolution for text rendering
                    plaqueTextCanvas.height = 64; // High resolution for text rendering

                    plaqueTextContext.font = 'Bold 30px "Inter"'; // Keep font size consistent on canvas
                    plaqueTextContext.fillStyle = '#151000'; // Dark text on gold
                    plaqueTextContext.textAlign = 'center';
                    plaqueTextContext.textBaseline = 'middle';
                    plaqueTextContext.fillText(art.name, plaqueTextCanvas.width / 2, plaqueTextCanvas.height / 2);

                    const plaqueTextTexture = new THREE.CanvasTexture(plaqueTextCanvas);
                    const plaqueTextMaterial = new THREE.MeshBasicMaterial({ map: plaqueTextTexture, transparent: true, side: THREE.DoubleSide });

                    // Define the world dimensions for the text plane to control its visual size
                    const textPlaneHeightInWorldUnits = 0.08; // Desired visual height of the text
                    const textPlaneWidthInWorldUnits = textPlaneHeightInWorldUnits * (plaqueTextCanvas.width / plaqueTextCanvas.height);

                    const plaqueTextPlane = new THREE.Mesh(new THREE.PlaneGeometry(textPlaneWidthInWorldUnits, textPlaneHeightInWorldUnits), plaqueTextMaterial);
                    
                    plaqueTextPlane.position.y = plaqueMesh.position.y; // Same Y as plaque
                    plaqueTextPlane.position.z = plaqueMesh.position.z + plaqueDepth / 2 + 0.002; // Slightly in front of plaque

                    artworkGroup.add(plaqueTextPlane); // Add text plane to artwork group
                    
                    // Position and rotate the entire group
                    artworkGroup.position.set(x, y, z);
                    artworkGroup.rotation.y = rotationY;

                    // Add a spotlight for each painting
                    const spotLight = new THREE.SpotLight(0xffffff, 0.8, 10, Math.PI / 8, 0.5, 2);
                    spotLight.position.set(x, 3, z); // Position spotlight on the ceiling
                    spotLight.target = artworkGroup; // Aim the spotlight at the artwork
                    spotLight.castShadow = true;
                    scene.add(spotLight);
                    scene.add(spotLight.target);

                    // Store data on the interactive part (the visible artwork plane) for popups
                    artMesh.userData.targetHeight = artworkHeight;
                    artMesh.userData.artworkData = art;
                    interactiveArtworks.push(artMesh); // Add plane to interactive list for hover detection

                    scene.add(artworkGroup);
                });
            }

            // Populate the gallery
            const artworkY = 1.6; // Vertical position of artworks

            // Paintings on side walls
            const leftWallX = -roomSize / 2 + wallThickness + 0.1;
            const rightWallX = roomSize / 2 - wallThickness - 0.1;

            const paintings = artworks.Paintings;
            if (paintings.length > 0) {
                const half = Math.ceil(paintings.length / 2);
                const leftWallPaintings = paintings.slice(0, half);
                const rightWallPaintings = paintings.slice(half);

                // Left Wall
                const leftSpacing = roomSize / (leftWallPaintings.length + 1);
                leftWallPaintings.forEach((art, index) => {
                    const zPos = -roomSize / 2 + leftSpacing * (index + 1);
                    createArtwork(leftWallX, artworkY, zPos, Math.PI / 2, 'painting', art);
                });

                // Right Wall
                const rightSpacing = roomSize / (rightWallPaintings.length + 1);
                rightWallPaintings.forEach((art, index) => {
                    const zPos = -roomSize / 2 + rightSpacing * (index + 1);
                    createArtwork(rightWallX, artworkY, zPos, -Math.PI / 2, 'painting', art);
                });
            } else {
                // One blank canvas if no paintings, place it on the left wall
                createArtwork(leftWallX, artworkY, 0, Math.PI / 2, 'painting', null);
            }

            // Digital art is now on the screen, so we remove the old placement logic for it.

            addCeilingLights();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('threejs-container').appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize);

            // Event listeners for the artwork modal
            modalCloseBtn.addEventListener('click', hideArtworkModal);
            artworkModal.addEventListener('click', (e) => {
                if (e.target === artworkModal) { // Only close if clicking the background
                    hideArtworkModal();
                }
            });
        }

        function showArtworkModal(imagePath) {
            modalArtworkImg.src = imagePath;
            artworkModal.style.display = 'flex'; // Show the modal

            // Hide the main menu and blocker when the artwork modal is shown
            menuContainer.style.display = 'none';
            blocker.style.display = 'none';
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function hideArtworkModal() {
            artworkModal.style.display = 'none'; // Hide the modal
            modalArtworkImg.src = ''; // Clear the image source

            // Show the main menu and blocker again when the artwork modal is hidden
            menuContainer.style.display = 'flex';
            blocker.style.display = 'block';
            renderMenuColumns([]); // Re-render menu to ensure correct state
        }

        function renderMenuColumns(currentPath) {
            const wrapper = document.getElementById('menu-columns-wrapper');
            wrapper.innerHTML = '';
            let itemsForNextColumn = menuData.children;
            let currentPathSegmentForListeners = [];

            for (let columnIndex = 0; ; columnIndex++) {
                if (!itemsForNextColumn || itemsForNextColumn.length === 0) break;
                const columnDiv = document.createElement('div');
                columnDiv.style.minWidth = '280px';
                columnDiv.style.maxWidth = '320px';
                columnDiv.style.overflowY = 'auto';
                columnDiv.style.marginRight = '0.5rem';

                itemsForNextColumn.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'menu-item flex flex-col items-start';
                    itemDiv.dataset.name = item.name;
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = item.name;
                    itemDiv.appendChild(nameSpan);

                    if (item.subtitle) {
                        const subtitleDiv = document.createElement('div');
                        subtitleDiv.className = 'subtitle';
                        subtitleDiv.textContent = item.subtitle;
                        itemDiv.appendChild(subtitleDiv);
                    }
                    if (item.children && item.children.length > 0) {
                        itemDiv.addEventListener('mouseenter', () => {
                            const newPath = currentPathSegmentForListeners.slice(0, columnIndex);
                            newPath.push(item);
                            renderMenuColumns(newPath);
                        });
                    }
                    itemDiv.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (item.link) { 
                            // Check if the link is an image file (for artwork popup)
                            if (item.link.match(/\.(jpeg|jpg|gif|png|webp)$/i)) {
                                showArtworkModal(item.link);
                            } else {
                                // For other links (like "Back to Main Page")
                                console.log("Navigating to:", item.name, "Path:", item.link);
                                window.location.href = item.link;
                            }
                        }
                    });
                    columnDiv.appendChild(itemDiv);
                });
                wrapper.appendChild(columnDiv);

                if (currentPath[columnIndex]) {
                    itemsForNextColumn = currentPath[columnIndex].children;
                    currentPathSegmentForListeners.push(currentPath[columnIndex]);
                } else { break; }
            }
        }
        
        function formatArtworkInfo(artwork) {
            if (!artwork) return "";
            let info = `${artwork.name}`; 
            if (artwork.artist) info += ` by ${artwork.artist}`;
            if (artwork.year) info += `, ${artwork.year}`;
            if (artwork.medium) info += `, ${artwork.medium}`;
            return info;
        }

        // Function to draw the scrolling text on the canvas
        function drawScrollingText() {
            if (!textCanvasContext) return;

            // Clear previous text
            textCanvasContext.clearRect(0, 0, textCanvas.width, textCanvas.height);

            // Set text properties
            textCanvasContext.font = '700 60px "Doto"';
            textCanvasContext.fillStyle = '#0AAFFF';
            textCanvasContext.textAlign = 'left'; // Align left for scrolling
            textCanvasContext.textBaseline = 'middle';

            // Add text shadow for glow effect
            textCanvasContext.shadowColor = '#0AAFFF';
            textCanvasContext.shadowBlur = 8;
            textCanvasContext.shadowOffsetX = 0;
            textCanvasContext.shadowOffsetY = 0;

            // Draw text at the current scroll offset
            // If text is wider than canvas, draw it twice for seamless looping
            if (textWidth > digitalScreenWidth * (textCanvas.width / digitalArtworkInfoMesh.geometry.parameters.width)) { // Compare pixel width with effective screen pixel width
                textCanvasContext.fillText(currentInfoText, textScrollOffset, textCanvas.height / 2);
                // Draw a second instance of the text after the first one, with some spacing
                const spacing = 50; // Pixels between repeated text
                textCanvasContext.fillText(currentInfoText, textScrollOffset + textWidth + spacing, textCanvas.height / 2);
            } else {
                // If text fits, just center it
                textCanvasContext.textAlign = 'center';
                textCanvasContext.fillText(currentInfoText, textCanvas.width / 2, textCanvas.height / 2);
            }

            // Update the texture
            digitalArtworkInfoMesh.material.map.needsUpdate = true;
        }

        function shuffleDigitalArtworks() {
            // Create an array of indices [0, 1, 2, ...]
            shuffledDigitalArtIndices = Array.from(artworks.Digital.keys());

            // Fisher-Yates (aka Knuth) Shuffle
            for (let i = shuffledDigitalArtIndices.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledDigitalArtIndices[i], shuffledDigitalArtIndices[j]] = [shuffledDigitalArtIndices[j], shuffledDigitalArtIndices[i]];
            }
            currentShuffledIndex = 0;
        }

        // Function to update the digital switching image and the Three.js info text
        function updateDigitalSwitchingImage(artworkIndex) {
            if (!digitalSwitchingImagePlane || !digitalArtworkInfoMesh) return;

            const digitalImagePaths = artworks.Digital.map(art => art.path);
            const loader = new THREE.TextureLoader();
            loader.load(digitalImagePaths[artworkIndex], function (texture) {
                if (!digitalSwitchingImagePlane) return; // Check again in case it was removed
                digitalSwitchingImagePlane.material.map = texture;
                digitalSwitchingImagePlane.material.needsUpdate = true;

                // Update the Three.js text mesh
                const art = artworks.Digital[artworkIndex];
                currentInfoText = formatArtworkInfo(art); // Store the current text

                // Measure text width
                textCanvasContext.font = '700 60px "Doto"'; // Ensure font is set for measurement
                const metrics = textCanvasContext.measureText(currentInfoText);
                textWidth = metrics.width; // Store actual text width

                // Reset scroll offset when new text loads
                // Start text from the right edge of the canvas if it needs to scroll, otherwise center
                if (textWidth > digitalScreenWidth * (textCanvas.width / digitalArtworkInfoMesh.geometry.parameters.width)) {
                    textScrollOffset = textCanvas.width;
                    isTextScrolling = true; // Text will start scrolling
                } else {
                    textScrollOffset = 0; // Not scrolling, centered
                    isTextScrolling = false; // Text does not need to scroll
                    lastScrollFinishTime = performance.now(); // Set finish time immediately if no scroll
                }
                
                // Initial draw
                drawScrollingText();
            });
        }

        let backWallPopupShown = false;
        let backWallForwardStart = null;
        const backWallPopup = document.getElementById('back-wall-popup');

        function showBackWallPopup() {
            if (backWallPopup) {
                backWallPopup.textContent = 'Going back to the Mall';
                backWallPopup.style.display = 'block';
                backWallPopupShown = true;
            }
        }
        function hideBackWallPopup() {
            if (backWallPopup) {
                backWallPopup.style.display = 'none';
                backWallPopupShown = false;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            if (controls.isLocked === true) {
                // Scrolling text logic
                const effectiveScreenWidthPixels = digitalScreenWidth * (textCanvas.width / digitalArtworkInfoMesh.geometry.parameters.width);
                const totalTextWidthWithSpacing = textWidth + 50; // textWidth + spacing from drawScrollingText

                if (isTextScrolling) {
                    textScrollOffset -= textScrollSpeed * 100 * delta; // Multiply by 100 to convert from world units to canvas pixels
                    
                    // Check if text has scrolled past its full length (plus spacing)
                    if (textScrollOffset < -totalTextWidthWithSpacing) {
                        // If it's the end of a full cycle for looping text, set scrolling to false
                        // This condition ensures the text completes one full pass before stopping or signaling completion
                        textScrollOffset = effectiveScreenWidthPixels; // Reset to start from right for next loop
                        isTextScrolling = false; // Signal that scrolling has completed a cycle
                        lastScrollFinishTime = time; // Record time when scrolling finished
                    }
                    drawScrollingText(); // Redraw text with new offset
                }

                // Digital artwork screen flipping logic (only if text is not scrolling OR text fits)
                if (!isTextScrolling && (time - lastScrollFinishTime > delayAfterScroll)) {
                    currentShuffledIndex++;
                    if (currentShuffledIndex >= shuffledDigitalArtIndices.length) {
                        shuffleDigitalArtworks(); // Reshuffle when the list is exhausted
                    }
                    const nextArtworkIndex = shuffledDigitalArtIndices[currentShuffledIndex];
                    updateDigitalSwitchingImage(nextArtworkIndex); // This will reset scrollOffset and set isTextScrolling=true if needed
                }

                // Raycasting for artwork hover
                raycaster.setFromCamera({ x: 0, y: 0 }, camera); // Ray from center of screen
                const intersects = raycaster.intersectObjects(interactiveArtworks, false); // Only check artworks

                if (intersects.length > 0) {
                    const intersectedObject = intersects[0].object;
                    const artworkData = intersectedObject.userData.artworkData;
                    const artworkHeightWorld = intersectedObject.userData.targetHeight; // Get the stored height

                    // Check if the intersected object is an artwork and if it's a new hover target
                    if (artworkData && currentHoveredArtwork !== artworkData) {
                        currentHoveredArtwork = artworkData;

                        // Calculate the world position of the top center of the artwork
                        const artworkTopCenterWorldPosition = new THREE.Vector3();
                        intersectedObject.getWorldPosition(artworkTopCenterWorldPosition); // Get current world position of object's center
                        artworkTopCenterWorldPosition.y += artworkHeightWorld / 2; // Move up to the top edge

                        // Project this world position to 2D screen coordinates
                        artworkTopCenterWorldPosition.project(camera);

                        // Calculate screen coordinates
                        const x = (artworkTopCenterWorldPosition.x * 0.5 + 0.5) * window.innerWidth;
                        const y = (-artworkTopCenterWorldPosition.y * 0.5 + 0.5) * window.innerHeight;

                        // Ensure artworkInfoPopup is defined before accessing its style
                        if (artworkInfoPopup) {
                            artworkInfoPopup.style.left = `${x + 15}px`; // Offset slightly to the right
                            artworkInfoPopup.style.top = `${y - 15}px`; // Offset slightly upwards
                            artworkInfoPopup.textContent = artworkData.name;
                            artworkInfoPopup.style.display = 'block';
                        }
                    }
                } else {
                    // Ensure artworkInfoPopup is defined before accessing its style
                    if (currentHoveredArtwork && artworkInfoPopup) {
                        artworkInfoPopup.style.display = 'none';
                        currentHoveredArtwork = null;
                    }
                }

                // --- Player movement logic from Mall.html ---
                // No gravity, no jumping, no Y velocity
                // Damping
                playerVelocity.x -= playerVelocity.x * 10.0 * delta;
                playerVelocity.z -= playerVelocity.z * 10.0 * delta;

                // Acceleration
                const accelerationFactor = playerSpeed * 8.0;
                if (moveForward) playerVelocity.z -= accelerationFactor * delta;
                if (moveBackward) playerVelocity.z += accelerationFactor * delta;
                if (moveLeft) playerVelocity.x -= accelerationFactor * delta;
                if (moveRight) playerVelocity.x += accelerationFactor * delta;

                const playerObject = controls.getObject();
                playerObject.translateX(playerVelocity.x * delta);
                playerObject.translateZ(playerVelocity.z * delta);
                playerObject.position.y = playerHeight; // Keep player at constant height

                // Prevent moving outside the room (wall collision)
                const camPos = playerObject.position;
                const buffer = wallThickness + 0.1; // A small buffer to prevent getting stuck
                const minBound = -roomSize / 2 + buffer;
                const maxBound = roomSize / 2 - buffer;
                camPos.x = Math.max(minBound, Math.min(maxBound, camPos.x));
                camPos.z = Math.max(minBound, Math.min(maxBound, camPos.z));

                // --- Front wall detection and redirect logic ---
                // Front wall is at z = +roomSize/2
                const frontWallZ = roomSize / 2;
                const closeToFrontWall = (frontWallZ - camPos.z) < (buffer + 0.05);
                // Facing the wall: camera looks within 45deg of +Z
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                const facingFrontWall = forward.z > 0.7; // cos(45deg) ~ 0.7
                if (closeToFrontWall && facingFrontWall && moveForward) {
                    if (!backWallPopupShown) {
                        showBackWallPopup();
                        backWallForwardStart = time;
                    } else {
                        // If popup is already shown and player keeps pressing W, check duration
                        if (backWallForwardStart && (time - backWallForwardStart > 1.0)) {
                            window.location.href = '../index.html';
                        }
                    }
                } else {
                    hideBackWallPopup();
                    backWallForwardStart = null;
                }
            }
            prevTime = time;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
