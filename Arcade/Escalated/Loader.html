<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animated Loader</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Ultra&family=Yellowtail&display=swap" rel="stylesheet">
    <!-- Tailwind CSS for basic body styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: "Inter", sans-serif; /* Default font */
            background-color: #000000; /* Ensure black background */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            position: relative; /* For absolute positioning of text containers */
        }

        #matrix-container {
            position: absolute;
            width: 75vw; /* Center 3/4 of the screen width */
            height: 100vh; /* Center 3/4 of the screen height */
            top: 0vh; /* (100 - 75) / 2 = 12.5vh from top */
            left: 12.5vw; /* (100 - 75) / 2 = 12.5vw from left */
            overflow: hidden; /* Hide characters outside this area */
            display: grid; /* Use CSS Grid for columns */
            grid-template-columns: repeat(9, 1fr); /* 9 equal columns */
            grid-template-rows: repeat(15, 1fr); /* 15 equal rows */
            font-family: 'Consolas', 'Monaco', 'Lucida Console', monospace; /* Monospaced font for matrix effect */
            font-weight: bold; /* Bold characters */
            white-space: nowrap; /* Prevent characters from wrapping */
            user-select: none; /* Prevent text selection */
        }

        .matrix-cell {
            display: flex;
            justify-content: center;
            align-items: center;
            height: calc(100% / 15); /* Divide container height into 15 rows for positioning */
            color: #008080; /* Darker teal color */
            font-size: clamp(0.8em, 2vw, 1.5em); /* Responsive font size for matrix characters */
            text-shadow: 0 0 3px #008080; /* Subtle glow */
            /* Transition for color change and fading */
            transition: color 0.05s ease-in-out, text-shadow 0.05s ease-in-out, opacity 1s ease-out;
        }

        /* --- NEW: Class for fading out matrix characters --- */
        .matrix-cell.fade-out {
            opacity: 0;
        }

        .matrix-cell.cyan {
            color: #00FFFF; /* Bright Cyan for cycling */
            text-shadow: 0 0 8px #00FFFF, 0 0 15px #00FFFF;
        }

        .matrix-cell.elevated-char { /* Apply elevated styles directly to the cell */
            color: #ADD8E6; /* Light Cyan color for ESCALATED letters */
            font-size: clamp(3em, 7vw, 5em); /* Doubled size */
            font-weight: bolder;
            z-index: 2; /* Ensure it's above other characters */
            text-shadow:  0 0 20px #1F51FF; /* Stronger glow */
            position: relative; /* Ensure z-index works */
            font-family: 'Ultra', 'Consolas', 'Monaco', 'Lucida Console', monospace, sans-serif; /* Default wide monospace */
            letter-spacing: 0.02em;      /* Reduced horizontal spacing */
            line-height: 0.7;            /* Tighter vertical spacing */
            padding-top: 0;
            padding-bottom: 0;
            transition: color 0.5s ease-in-out, text-shadow 0.5s ease-in-out; /* Smooth transition for final glow */
        }

        /* Final glow effect for ESCALATED */
        .final-glow {
            color: #FFFFFF !important; /* Pure white text, !important to override other styles */
            text-shadow: 0 0 4px #FFFFFF, 0 0 8px #4A90E2, 0 0 12px #0090E2 !important; /* White inner glow, UV Blue outer glow */
        }

        /* Styles for Bullet and Impact */
        .bullet {
            position: absolute;
            width: 10px;
            height: 4px;
            background-color: #FFFF00; /* Bright yellow */
            border-radius: 2px;
            box-shadow: 0 0 10px #FFFF00, 0 0 20px #FFFF00;
            z-index: 20;
            transition: transform 0.2s ease-out; /* Animation for movement */
            pointer-events: none;
        }

        .impact {
            color: #FFFFFF !important;
            text-shadow: 0 0 25px #FFFFFF, 0 0 40px #FFFF00 !important;
            transition: color 0.05s, text-shadow 0.05s;
        }


        /* Landscape: Use a wider font and increase letter spacing */
        @media (orientation: landscape) {
            .matrix-cell.elevated-char {
                font-family: 'Ultra', 'Arial Black', 'Consolas', 'Impact', 'Monaco', 'Lucida Console', monospace, sans-serif;
                letter-spacing: 0.12em;  /* Still less than before */
                line-height: 0.7;
            }
        }

        #mayhem-text-container-bottom-right { /* Renamed from action-text-container */
            position: absolute;
            bottom: 25%; /* 3/4 toward bottom */
            right: 5%; /* Position from right, responsive */
            color: #ADD8E6; /* UV Blue color */
            font-size: clamp(3em, 10vw, 6em); /* Doubled size */
            font-family: 'Yellowtail', cursive; /* Use Yellowtail font */
            text-shadow: 0 0 20px #0051FF; /* Stronger glow for larger text */
            z-index: 10; /* Ensure it's above everything */
            pointer-events: none; /* Allow clicks to pass through */
            opacity: 0; /* Initially hidden */
            transition: opacity 2s ease-in; /* Fade in effect */
        }

        #mayhem-text-container-bottom-right.show {
            opacity: 1;
        }

        #mayhem-text-container-bottom-right.flicker {
            animation: neon-flicker 1.2s linear 1;
        }

        @keyframes neon-flicker {
            0%   { opacity: 0; text-shadow: none; }
            5%   { opacity: 1; text-shadow: 0 0 20px #1F51FF, 0 0 40px #1F51FF; }
            10%  { opacity: 0.3; text-shadow: none; }
            15%  { opacity: 1; text-shadow: 0 0 20px #1F51FF, 0 0 40px #AFC3FF; }
            20%  { opacity: 0.2; text-shadow: none; }
            25%  { opacity: 0; text-shadow: 0 0 20px #1F51FF, 0 0 40px #1F51FF; }
            30%  { opacity: 0.5; text-shadow: none; }
            35%  { opacity: 1; text-shadow: 0 0 20px #1F51FF, 0 0 40px #AFC3FF; }
            40%  { opacity: 0.7; text-shadow: none; }
            45%  { opacity: 0; text-shadow: 0 0 20px #1F51FF, 0 0 40px #1F51FF; }
            50%  { opacity: 0.4; text-shadow: none; }
            55%  { opacity: 1; text-shadow: 0 0 20px #1F51FF, 0 0 40px #AFC3FF; }
            60%  { opacity: 0.6; text-shadow: none; }
            65%  { opacity: 0; text-shadow: 0 0 20px #1F51FF, 0 0 40px #1F51FF; }
            70%  { opacity: 0.8; text-shadow: none; }
            75%  { opacity: 1; text-shadow: 0 0 20px #1F51FF, 0 0 40px #AFC3FF; }
            80%  { opacity: 0.9; text-shadow: none; }
            85%  { opacity: 1; text-shadow: 0 0 20px #1F51FF, 0 0 40px #1F51FF; }
            90%  { opacity: 0.7; text-shadow: none; }
            95%  { opacity: 0; text-shadow: 0 0 20px #1F51FF, 0 0 40px #AFC3FF; }
            100% { opacity: 1; text-shadow: 0 0 20px #1F51FF, 0 0 40px #AFC3FF; }
        }
    </style>
</head>
<body>
    <!-- Container for the Matrix effect -->
    <div id="matrix-container"></div>

    <!-- Container for the "Mayhem" text (repurposed from "Action") -->
    <div id="mayhem-text-container-bottom-right">Mayhem</div>

    <script>
        // --- Global Variables ---
        const matrixContainer = document.getElementById('matrix-container');
        const mayhemTextContainerBottomRight = document.getElementById('mayhem-text-container-bottom-right');
        const numColumns = 9;
        const numRows = 15;
        const animationSpeed = 25; // Milliseconds per character cycle/step
        const cycleDuration = 3; // Number of random character cycles before settling

        let currentColumnIndex = 0;
        let currentRowIndex = 0;
        let cycleCount = 0;
        let animationComplete = false;

        const allChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789一二三四五六七八九十上下左右中大小月日年时分秒天地人出入口子手动工开学文京东西南北来去";

        const escalatedLettersData = [
            { char: 'E', col: 0, row: Math.floor(numRows * (11 / 15)) },
            { char: 'S', col: 1, row: Math.floor(numRows * (10 / 15)) },
            { char: 'C', col: 2, row: Math.floor(numRows * (9 / 15)) },
            { char: 'A', col: 3, row: Math.floor(numRows * (8 / 15)) },
            { char: 'L', col: 4, row: Math.floor(numRows * (7 / 15)) },
            { char: 'A', col: 5, row: Math.floor(numRows * (6 / 15)) },
            { char: 'T', col: 6, row: Math.floor(numRows * (5 / 15)) },
            { char: 'E', col: 7, row: Math.floor(numRows * (4 / 15)) },
            { char: 'D', col: 8, row: Math.floor(numRows * (3 / 15)) }
        ];

        const matrixCells = [];

        // --- Initialization Function ---
        function init() {
            for (let r = 0; r < numRows; r++) {
                matrixCells[r] = [];
                for (let c = 0; c < numColumns; c++) {
                    const cellDiv = document.createElement('div');
                    cellDiv.classList.add('matrix-cell');
                    matrixContainer.appendChild(cellDiv);
                    matrixCells[r][c] = cellDiv;
                }
            }
            startInitialAnimation();
        }

        // --- Helper Functions ---
        function interpolateColor(color1, color2, factor) {
            let c1 = color1.match(/\w\w/g).map(x => parseInt(x, 16));
            let c2 = color2.match(/\w\w/g).map(x => parseInt(x, 16));
            let result = c1.map((v, i) => Math.round(v + (c2[i] - v) * factor));
            return `#${result.map(x => x.toString(16).padStart(2, '0')).join('')}`;
        }

        function adjustBrightness(hex, factor) {
            let rgb = hex.match(/\w\w/g).map(x => parseInt(x, 16));
            // Fixed: Added a missing closing parenthesis after Math.round(v * factor)
            let adjusted = rgb.map(v => Math.min(255, Math.max(0, Math.round(v * factor))));
            return `#${adjusted.map(x => x.toString(16).padStart(2, '0')).join('')}`;
        }

        // --- Initial Animation Logic ---
        function startInitialAnimation() {
            if (animationComplete) return;
            if (currentColumnIndex >= numColumns) {
                animationComplete = true;
                triggerSecondaryAnimations();
                return;
            }
            const currentCell = matrixCells[currentRowIndex][currentColumnIndex];
            const escalatedLetter = escalatedLettersData.find(
                data => data.col === currentColumnIndex && data.row === currentRowIndex
            );
            if (cycleCount < cycleDuration) {
                currentCell.textContent = allChars[Math.floor(Math.random() * allChars.length)];
                currentCell.classList.toggle('cyan');
                cycleCount++;
                setTimeout(startInitialAnimation, animationSpeed);
            } else {
                currentCell.classList.remove('cyan');
                if (escalatedLetter) {
                    currentCell.textContent = escalatedLetter.char;
                    currentCell.classList.add('elevated-char');
                    currentRowIndex = 0;
                    currentColumnIndex++;
                    cycleCount = 0;
                } else {
                    const factor = currentRowIndex / (numRows - 1);
                    let baseColor = interpolateColor('000808', '00bbbb', factor);
                    const brightnessFactor = 0.9 + Math.random() * 0.2;
                    let variedColor = adjustBrightness(baseColor, brightnessFactor);
                    currentCell.style.color = variedColor;
                    currentCell.style.textShadow = `0 0 3px ${variedColor}, 0 0 8px ${variedColor}`;
                    currentRowIndex++;
                    cycleCount = 0;
                }
                setTimeout(startInitialAnimation, animationSpeed);
            }
        }

        // --- Function to handle all post-initial animations ---
        function triggerSecondaryAnimations() {
            showMayhem();
            setTimeout(startBulletAnimation, 2000);
        }

        // --- Show Mayhem Text ---
        function showMayhem() {
            mayhemTextContainerBottomRight.classList.add('show');
        }

        // --- Bullet Animation Logic ---
        function startBulletAnimation() {
            const elevatedCells = Array.from(document.querySelectorAll('.elevated-char'));
            let bulletIndex = 0;

            function shootNextBullet() {
                if (bulletIndex >= elevatedCells.length) {
                    setTimeout(startRotationAnimation, 300);
                    return;
                }
                const targetCell = elevatedCells[bulletIndex];
                const targetRect = targetCell.getBoundingClientRect();
                const bullet = document.createElement('div');
                bullet.className = 'bullet';
                document.body.appendChild(bullet);
                const startX = -20;
                const startY = targetRect.top + (targetRect.height / 2) - (bullet.offsetHeight / 2);
                bullet.style.left = `${startX}px`;
                bullet.style.top = `${startY}px`;
                requestAnimationFrame(() => {
                    const endX = targetRect.left;
                    bullet.style.transform = `translateX(${endX - startX}px)`;
                });
                setTimeout(() => {
                    targetCell.classList.add('impact');
                    setTimeout(() => {
                        targetCell.classList.remove('impact');
                    }, 100);
                    bullet.remove();
                    bulletIndex++;
                    setTimeout(shootNextBullet, 100);
                }, 200);
            }
            shootNextBullet();
        }

        // --- Rotation Animation Logic ---
        function startRotationAnimation() {
            // --- NEW: Start the background fade-out simultaneously ---
            fadeMatrixCharacters();

            const elevatedCells = Array.from(document.querySelectorAll('.elevated-char'));
            const originalChars = elevatedCells.map(cell => cell.textContent).join(''); // Join to compare as string
            let currentChars = [...originalChars]; // Use spread to create a new array
            let lastRemovedChar = ''; // To store the character that "falls off"

            const rotationInterval = setInterval(() => {
                // Store the character that will be replaced by the "•"
                const firstChar = currentChars[0];

                // Shift characters up
                for (let i = 0; i < currentChars.length - 1; i++) {
                    currentChars[i] = currentChars[i + 1];
                }

                // The last character is now the one that was at the second to last position.
                // The character that was originally at the last position is now 'lost' in this shift,
                // so we need to put 'lastRemovedChar' in the last position.
                // If lastRemovedChar is empty (first cycle), we'll replace the last char with '•'
                const charToPlaceAtEnd = lastRemovedChar === '' ? '•' : lastRemovedChar;
                lastRemovedChar = firstChar; // The character that was at the first position is now the one to be remembered for the next cycle.
                currentChars[currentChars.length - 1] = charToPlaceAtEnd;

                // Update the display
                elevatedCells.forEach((cell, index) => {
                    cell.textContent = currentChars[index];
                });

                // Check if the word "ESCALATED" is complete again
                if (currentChars.join('') === originalChars) {
                    clearInterval(rotationInterval);
                    setTimeout(() => applyFinalGlow(elevatedCells), 500);
                }
            }, 150);
        }


        // --- NEW: Function to fade out background matrix characters ---
        function fadeMatrixCharacters() {
            let row = 0;
            const fadeInterval = setInterval(() => {
                if (row >= numRows) {
                    clearInterval(fadeInterval);
                    return;
                }
                for (let col = 0; col < numColumns; col++) {
                    const cell = matrixCells[row][col];
                    // Check if it's not one of the main letters
                    if (!cell.classList.contains('elevated-char')) {
                        cell.classList.add('fade-out');
                    }
                }
                row++;
            }, 75); // Delay between each row fading to create a top-to-bottom effect
        }

        // --- Final Glow Effect ---
        function applyFinalGlow(cells) {
            cells.forEach(cell => {
                cell.classList.add('final-glow');
            });
        }

        // --- Start the loader when the window is fully loaded ---
        window.onload = init;

    </script>
</body>
</html>
