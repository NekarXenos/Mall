<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Marching Cubes Planet Miner (FPS)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #1a1a2e; color: #e0e0e0; -webkit-user-select: none; user-select: none; }v
        canvas { display: block; width: 100vw; height: 100vh; }
        #message-box {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 10px;
            color: #fff;
            font-size: 1.2em;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            z-index: 100;
        }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 200;
            color: white;
            font-size: 2em;
            cursor: pointer;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin-left: -10px;
            margin-top: -10px;
            border: 2px solid white;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            z-index: 100;
        }
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 150;
            pointer-events: none; /* Allows clicks to pass through if not on buttons */
        }
        #joystick-area, #mine-button-area {
            pointer-events: auto; /* Re-enable pointer events for controls */
            display: flex;
            align-items: center;
        }
        #joystick-base {
            width: 100px;
            height: 100px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            touch-action: none; /* Prevent browser default touch actions */
        }
        #joystick-thumb {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            touch-action: none;
        }
        #mine-button {
            background-color: #007bff; /* Blue button */
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1.2em;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: background-color 0.2s ease-in-out;
        }
        #mine-button:active {
            background-color: #0056b3; /* Darker blue on click */
        }
    </style>
</head>
<body>
    <div id="message-box">Click or tap to play!</div>
    <div id="overlay">Click to start</div>
    <div id="crosshair"></div>

    <div id="mobile-controls">
        <div id="joystick-area">
            <div id="joystick-base">
                <div id="joystick-thumb"></div>
            </div>
        </div>
        <div id="mine-button-area">
            <button id="mine-button">MINE</button>
        </div>
    </div>

    <script type="module">
        // Lookup Tables for Marching Cubes (copied from MarchingCubes.js for self-containment)
        const EdgeVertexIndices = [
            [0, 1], [1, 3], [3, 2], [2, 0], [4, 5], [5, 7], [7, 6], [6, 4],
            [0, 4], [1, 5], [3, 7], [2, 6],
        ];

        const EdgeMasks = [
            0x0, 0x109, 0x203, 0x30a, 0x80c, 0x905, 0xa0f, 0xb06,
            0x406, 0x50f, 0x605, 0x70c, 0xc0a, 0xd03, 0xe09, 0xf00,
            0x190, 0x99, 0x393, 0x29a, 0x99c, 0x895, 0xb9f, 0xa96,
            0x596, 0x49f, 0x795, 0x69c, 0xd9a, 0xc93, 0xf99, 0xe90,
            0x230, 0x339, 0x33, 0x13a, 0xa3c, 0xb35, 0x83f, 0x936,
            0x636, 0x73f, 0x435, 0x53c, 0xe3a, 0xf33, 0xc39, 0xd30,
            0x3a0, 0x2a9, 0x1a3, 0xaa, 0xbac, 0xaa5, 0x9af, 0x8a6,
            0x7a6, 0x6af, 0x5a5, 0x4ac, 0xfaa, 0xea3, 0xda9, 0xca0,
            0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc, 0x1c5, 0x2cf, 0x3c6,
            0xcc6, 0xdcf, 0xec5, 0xfcc, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
            0x950, 0x859, 0xb53, 0xa5a, 0x15c, 0x55, 0x35f, 0x256,
            0xd56, 0xc5f, 0xf55, 0xe5c, 0x55a, 0x453, 0x759, 0x650,
            0xaf0, 0xbf9, 0x8f3, 0x9fa, 0x2fc, 0x3f5, 0xff, 0x1f6,
            0xef6, 0xfff, 0xcf5, 0xdfc, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
            0xb60, 0xa69, 0x963, 0x86a, 0x36c, 0x265, 0x16f, 0x66,
            0xf66, 0xe6f, 0xd65, 0xc6c, 0x76a, 0x663, 0x569, 0x460,
            0x460, 0x569, 0x663, 0x76a, 0xc6c, 0xd65, 0xe6f, 0xf66,
            0x66, 0x16f, 0x265, 0x36c, 0x86a, 0x963, 0xa69, 0xb60,
            0x5f0, 0x4f9, 0x7f3, 0x6fa, 0xdfc, 0xcf5, 0xfff, 0xef6,
            0x1f6, 0xff, 0x3f5, 0x2fc, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
            0x650, 0x759, 0x453, 0x55a, 0xe5c, 0xf55, 0xc5f, 0xd56,
            0x256, 0x35f, 0x55, 0x15c, 0xa5a, 0xb53, 0x859, 0x950,
            0x7c0, 0x6c9, 0x5c3, 0x4ca, 0xfcc, 0xec5, 0xdcf, 0xcc6,
            0x3c6, 0x2cf, 0x1c5, 0xcc, 0xbca, 0xac3, 0x9c9, 0x8c0,
            0xca0, 0xda9, 0xea3, 0xfaa, 0x4ac, 0x5a5, 0x6af, 0x7a6,
            0x8a6, 0x9af, 0xaa5, 0xbac, 0xaa, 0x1a3, 0x2a9, 0x3a0,
            0xd30, 0xc39, 0xf33, 0xe3a, 0x53c, 0x435, 0x73f, 0x636,
            0x936, 0x83f, 0xb35, 0xa3c, 0x13a, 0x33, 0x339, 0x230,
            0xe90, 0xf99, 0xc93, 0xd9a, 0x69c, 0x795, 0x49f, 0x596,
            0xa96, 0xb9f, 0x895, 0x99c, 0x29a, 0x393, 0x99, 0x190,
            0xf00, 0xe09, 0xd03, 0xc0a, 0x70c, 0x605, 0x50f, 0x406,
            0xb06, 0xa0f, 0x905, 0x80c, 0x30a, 0x203, 0x109, 0x0,
        ];

        const TriangleTable = [
            [ -1 ],
            [ 0, 3, 8, -1 ], [ 0, 9, 1, -1 ], [ 3, 8, 1, 1, 8, 9, -1 ],
            [ 2, 11, 3, -1 ], [ 8, 0, 11, 11, 0, 2, -1 ], [ 3, 2, 11, 1, 0, 9, -1 ],
            [ 11, 1, 2, 11, 9, 1, 11, 8, 9, -1 ], [ 1, 10, 2, -1 ],
            [ 0, 3, 8, 2, 1, 10, -1 ], [ 10, 2, 9, 9, 2, 0, -1 ],
            [ 8, 2, 3, 8, 10, 2, 8, 9, 10, -1 ], [ 11, 3, 10, 10, 3, 1, -1 ],
            [ 10, 0, 1, 10, 8, 0, 10, 11, 8, -1 ],
            [ 9, 3, 0, 9, 11, 3, 9, 10, 11, -1 ], [ 8, 9, 11, 11, 9, 10, -1 ],
            [ 4, 8, 7, -1 ], [ 7, 4, 3, 3, 4, 0, -1 ], [ 4, 8, 7, 0, 9, 1, -1 ],
            [ 1, 4, 9, 1, 7, 4, 1, 3, 7, -1 ], [ 8, 7, 4, 11, 3, 2, -1 ],
            [ 4, 11, 7, 4, 2, 11, 4, 0, 2, -1 ],
            [ 0, 9, 1, 8, 7, 4, 11, 3, 2, -1 ],
            [ 7, 4, 11, 11, 4, 2, 2, 4, 9, 2, 9, 1, -1 ],
            [ 4, 8, 7, 2, 1, 10, -1 ],
            [ 7, 4, 3, 3, 4, 0, 10, 2, 1, -1 ],
            [ 10, 2, 9, 9, 2, 0, 7, 4, 8, -1 ],
            [ 10, 2, 3, 10, 3, 4, 3, 7, 4, 9, 10, 4, -1 ],
            [ 1, 10, 3, 3, 10, 11, 4, 8, 7, -1 ],
            [ 10, 11, 1, 11, 7, 4, 1, 11, 4, 1, 4, 0, -1 ],
            [ 7, 4, 8, 9, 3, 0, 9, 11, 3, 9, 10, 11, -1 ],
            [ 7, 4, 11, 4, 9, 11, 9, 10, 11, -1 ],
            [ 9, 4, 5, -1 ], [ 9, 4, 5, 8, 0, 3, -1 ], [ 4, 5, 0, 0, 5, 1, -1 ],
            [ 5, 8, 4, 5, 3, 8, 5, 1, 3, -1 ], [ 9, 4, 5, 11, 3, 2, -1 ],
            [ 2, 11, 0, 0, 11, 8, 5, 9, 4, -1 ],
            [ 4, 5, 0, 0, 5, 1, 11, 3, 2, -1 ],
            [ 5, 1, 4, 1, 2, 11, 4, 1, 11, 4, 11, 8, -1 ],
            [ 1, 10, 2, 5, 9, 4, -1 ],
            [ 9, 4, 5, 0, 3, 8, 2, 1, 10, -1 ],
            [ 2, 5, 10, 2, 4, 5, 2, 0, 4, -1 ],
            [ 10, 2, 5, 5, 2, 4, 4, 2, 3, 4, 3, 8, -1 ],
            [ 11, 3, 10, 10, 3, 1, 4, 5, 9, -1 ],
            [ 4, 5, 9, 10, 0, 1, 10, 8, 0, 10, 11, 8, -1 ],
            [ 11, 3, 0, 11, 0, 5, 0, 4, 5, 10, 11, 5, -1 ],
            [ 4, 5, 8, 5, 10, 8, 10, 11, 8, -1 ],
            [ 8, 7, 9, 9, 7, 5, -1 ],
            [ 3, 9, 0, 3, 5, 9, 3, 7, 5, -1 ],
            [ 7, 0, 8, 7, 1, 0, 7, 5, 1, -1 ],
            [ 7, 5, 3, 3, 5, 1, -1 ],
            [ 5, 9, 7, 7, 9, 8, 2, 11, 3, -1 ],
            [ 2, 11, 7, 2, 7, 9, 7, 5, 9, 0, 2, 9, -1 ],
            [ 2, 11, 3, 7, 0, 8, 7, 1, 0, 7, 5, 1, -1 ],
            [ 2, 11, 1, 11, 7, 1, 7, 5, 1, -1 ],
            [ 8, 7, 9, 9, 7, 5, 2, 1, 10, -1 ],
            [ 10, 2, 1, 3, 9, 0, 3, 5, 9, 3, 7, 5, -1 ],
            [ 7, 5, 8, 5, 10, 2, 8, 5, 2, 8, 2, 0, -1 ],
            [ 10, 2, 5, 2, 3, 5, 3, 7, 5, -1 ],
            [ 8, 7, 5, 8, 5, 9, 11, 3, 10, 3, 1, 10, -1 ],
            [ 5, 11, 7, 10, 11, 5, 1, 9, 0, -1 ],
            [ 11, 5, 10, 7, 5, 11, 8, 3, 0, -1 ],
            [ 5, 11, 7, 10, 11, 5, -1 ],
            [ 6, 7, 11, -1 ], [ 7, 11, 6, 3, 8, 0, -1 ],
            [ 6, 7, 11, 0, 9, 1, -1 ],
            [ 9, 1, 8, 8, 1, 3, 6, 7, 11, -1 ],
            [ 3, 2, 7, 7, 2, 6, -1 ],
            [ 0, 7, 8, 0, 6, 7, 0, 2, 6, -1 ],
            [ 6, 7, 2, 2, 7, 3, 9, 1, 0, -1 ],
            [ 6, 7, 8, 6, 8, 1, 8, 9, 1, 2, 6, 1, -1 ],
            [ 11, 6, 7, 10, 2, 1, -1 ],
            [ 3, 8, 0, 11, 6, 7, 10, 2, 1, -1 ],
            [ 0, 9, 2, 2, 9, 10, 7, 11, 6, -1 ],
            [ 6, 7, 11, 8, 2, 3, 8, 10, 2, 8, 9, 10, -1 ],
            [ 7, 10, 6, 7, 1, 10, 7, 3, 1, -1 ],
            [ 8, 0, 7, 7, 0, 6, 6, 0, 1, 6, 1, 10, -1 ],
            [ 7, 3, 6, 3, 0, 9, 6, 3, 9, 6, 9, 10, -1 ],
            [ 6, 7, 10, 7, 8, 10, 8, 9, 10, -1 ],
            [ 11, 6, 8, 8, 6, 4, -1 ],
            [ 6, 3, 11, 6, 0, 3, 6, 4, 0, -1 ],
            [ 11, 6, 8, 8, 6, 4, 1, 0, 9, -1 ],
            [ 1, 3, 9, 3, 11, 6, 9, 3, 6, 9, 6, 4, -1 ],
            [ 2, 8, 3, 2, 4, 8, 2, 6, 4, -1 ], [ 4, 0, 6, 6, 0, 2, -1 ],
            [ 9, 1, 0, 2, 8, 3, 2, 4, 8, 2, 6, 4, -1 ],
            [ 9, 1, 4, 1, 2, 4, 2, 6, 4, -1 ],
            [ 4, 8, 6, 6, 8, 11, 1, 10, 2, -1 ],
            [ 1, 10, 2, 6, 3, 11, 6, 0, 3, 6, 4, 0, -1 ],
            [ 11, 6, 4, 11, 4, 8, 10, 2, 9, 2, 0, 9, -1 ],
            [ 10, 4, 9, 6, 4, 10, 11, 2, 3, -1 ],
            [ 4, 8, 3, 4, 3, 10, 3, 1, 10, 6, 4, 10, -1 ],
            [ 1, 10, 0, 10, 6, 0, 6, 4, 0, -1 ],
            [ 4, 10, 6, 9, 10, 4, 0, 8, 3, -1 ],
            [ 4, 10, 6, 9, 10, 4, -1 ],
            [ 6, 7, 11, 4, 5, 9, -1 ],
            [ 4, 5, 9, 7, 11, 6, 3, 8, 0, -1 ],
            [ 1, 0, 5, 5, 0, 4, 11, 6, 7, -1 ],
            [ 11, 6, 7, 5, 8, 4, 5, 3, 8, 5, 1, 3, -1 ],
            [ 3, 2, 7, 7, 2, 6, 9, 4, 5, -1 ],
            [ 5, 9, 4, 0, 7, 8, 0, 6, 7, 0, 2, 6, -1 ],
            [ 3, 2, 6, 3, 6, 7, 1, 0, 5, 0, 4, 5, -1 ],
            [ 6, 1, 2, 5, 1, 6, 4, 7, 8, -1 ],
            [ 10, 2, 1, 6, 7, 11, 4, 5, 9, -1 ],
            [ 0, 3, 8, 4, 5, 9, 11, 6, 7, 10, 2, 1, -1 ],
            [ 7, 11, 6, 2, 5, 10, 2, 4, 5, 2, 0, 4, -1 ],
            [ 8, 4, 7, 5, 10, 6, 3, 11, 2, -1 ],
            [ 9, 4, 5, 7, 10, 6, 7, 1, 10, 7, 3, 1, -1 ],
            [ 10, 6, 5, 7, 8, 4, 1, 9, 0, -1 ],
            [ 4, 3, 0, 7, 3, 4, 6, 5, 10, -1 ],
            [ 10, 6, 5, 8, 4, 7, -1 ],
            [ 9, 6, 5, 9, 11, 6, 9, 8, 11, -1 ],
            [ 11, 6, 3, 3, 6, 0, 0, 6, 5, 0, 5, 9, -1 ],
            [ 11, 6, 5, 11, 5, 0, 5, 1, 0, 8, 11, 0, -1 ],
            [ 11, 6, 3, 6, 5, 3, 5, 1, 3, -1 ],
            [ 9, 8, 5, 8, 3, 2, 5, 8, 2, 6, 5, 2, -1 ],
            [ 5, 9, 6, 9, 0, 6, 0, 2, 6, -1 ],
            [ 1, 6, 5, 2, 6, 1, 3, 0, 8, -1 ],
            [ 1, 6, 5, 2, 6, 1, -1 ],
            [ 2, 1, 10, 9, 6, 5, 9, 11, 6, 9, 8, 11, -1 ],
            [ 9, 0, 1, 3, 11, 2, 5, 10, 6, -1 ],
            [ 11, 0, 8, 2, 0, 11, 10, 6, 5, -1 ],
            [ 3, 11, 2, 5, 10, 6, -1 ],
            [ 1, 8, 3, 9, 8, 1, 5, 10, 6, -1 ],
            [ 6, 5, 10, 0, 1, 9, -1 ],
            [ 8, 3, 0, 5, 10, 6, -1 ],
            [ 6, 5, 10, -1 ],
            [ 10, 5, 6, -1 ], [ 0, 3, 8, 6, 10, 5, -1 ],
            [ 10, 5, 6, 9, 1, 0, -1 ],
            [ 3, 8, 1, 1, 8, 9, 6, 10, 5, -1 ],
            [ 2, 11, 3, 6, 10, 5, -1 ],
            [ 8, 0, 11, 11, 0, 2, 5, 6, 10, -1 ],
            [ 1, 0, 9, 2, 11, 3, 6, 10, 5, -1 ],
            [ 5, 6, 10, 11, 1, 2, 11, 9, 1, 11, 8, 9, -1 ],
            [ 5, 6, 1, 1, 6, 2, -1 ],
            [ 5, 6, 1, 1, 6, 2, 8, 0, 3, -1 ],
            [ 6, 9, 5, 6, 0, 9, 6, 2, 0, -1 ],
            [ 6, 2, 5, 2, 3, 8, 5, 2, 8, 5, 8, 9, -1 ],
            [ 3, 6, 11, 3, 5, 6, 3, 1, 5, -1 ],
            [ 8, 0, 1, 8, 1, 6, 1, 5, 6, 11, 8, 6, -1 ],
            [ 11, 3, 6, 6, 3, 5, 5, 3, 0, 5, 0, 9, -1 ],
            [ 5, 6, 9, 6, 11, 9, 11, 8, 9, -1 ],
            [ 5, 6, 10, 7, 4, 8, -1 ],
            [ 0, 3, 4, 4, 3, 7, 10, 5, 6, -1 ],
            [ 5, 6, 10, 4, 8, 7, 0, 9, 1, -1 ],
            [ 6, 10, 5, 1, 4, 9, 1, 7, 4, 1, 3, 7, -1 ],
            [ 7, 4, 8, 6, 10, 5, 2, 11, 3, -1 ],
            [ 10, 5, 6, 4, 11, 7, 4, 2, 11, 4, 0, 2, -1 ],
            [ 4, 8, 7, 6, 10, 5, 3, 2, 11, 1, 0, 9, -1 ],
            [ 1, 2, 10, 11, 7, 6, 9, 5, 4, -1 ],
            [ 2, 1, 6, 6, 1, 5, 8, 7, 4, -1 ],
            [ 0, 3, 7, 0, 7, 4, 2, 1, 6, 1, 5, 6, -1 ],
            [ 8, 7, 4, 6, 9, 5, 6, 0, 9, 6, 2, 0, -1 ],
            [ 7, 2, 3, 6, 2, 7, 5, 4, 9, -1 ],
            [ 4, 8, 7, 3, 6, 11, 3, 5, 6, 3, 1, 5, -1 ],
            [ 5, 0, 1, 4, 0, 5, 7, 6, 11, -1 ],
            [ 9, 5, 4, 6, 11, 7, 0, 8, 3, -1 ],
            [ 11, 7, 6, 9, 5, 4, -1 ],
            [ 6, 10, 4, 4, 10, 9, -1 ],
            [ 6, 10, 4, 4, 10, 9, 3, 8, 0, -1 ],
            [ 0, 10, 1, 0, 6, 10, 0, 4, 6, -1 ],
            [ 6, 10, 1, 6, 1, 8, 1, 3, 8, 4, 6, 8, -1 ],
            [ 9, 4, 10, 10, 4, 6, 3, 2, 11, -1 ],
            [ 2, 11, 8, 2, 8, 0, 6, 10, 4, 10, 9, 4, -1 ],
            [ 11, 3, 2, 0, 10, 1, 0, 6, 10, 0, 4, 6, -1 ],
            [ 6, 8, 4, 11, 8, 6, 2, 10, 1, -1 ],
            [ 4, 1, 9, 4, 2, 1, 4, 6, 2, -1 ],
            [ 3, 8, 0, 4, 1, 9, 4, 2, 1, 4, 6, 2, -1 ],
            [ 6, 2, 4, 4, 2, 0, -1 ],
            [ 3, 8, 2, 8, 4, 2, 4, 6, 2, -1 ],
            [ 4, 6, 9, 6, 11, 3, 9, 6, 3, 9, 3, 1, -1 ],
            [ 8, 6, 11, 4, 6, 8, 9, 0, 1, -1 ],
            [ 11, 3, 6, 3, 0, 6, 0, 4, 6, -1 ],
            [ 8, 6, 11, 4, 6, 8, -1 ],
            [ 10, 7, 6, 10, 8, 7, 10, 9, 8, -1 ],
            [ 3, 7, 0, 7, 6, 10, 0, 7, 10, 0, 10, 9, -1 ],
            [ 6, 10, 7, 7, 10, 8, 8, 10, 1, 8, 1, 0, -1 ],
            [ 6, 10, 7, 10, 1, 7, 1, 3, 7, -1 ],
            [ 3, 2, 11, 10, 7, 6, 10, 8, 7, 10, 9, 8, -1 ],
            [ 2, 9, 0, 10, 9, 2, 6, 11, 7, -1 ],
            [ 0, 8, 3, 7, 6, 11, 1, 2, 10, -1 ],
            [ 7, 6, 11, 1, 2, 10, -1 ],
            [ 2, 1, 9, 2, 9, 7, 9, 8, 7, 6, 2, 7, -1 ],
            [ 2, 7, 6, 3, 7, 2, 0, 1, 9, -1 ],
            [ 8, 7, 0, 7, 6, 0, 6, 2, 0, -1 ],
            [ 7, 2, 3, 6, 2, 7, -1 ],
            [ 8, 1, 9, 3, 1, 8, 11, 7, 6, -1 ],
            [ 11, 7, 6, 1, 9, 0, -1 ],
            [ 6, 11, 7, 0, 8, 3, -1 ],
            [ 11, 7, 6, -1 ],
            [ 7, 11, 5, 5, 11, 10, -1 ],
            [ 10, 5, 11, 11, 5, 7, 0, 3, 8, -1 ],
            [ 7, 11, 5, 5, 11, 10, 0, 9, 1, -1 ],
            [ 7, 11, 10, 7, 10, 5, 3, 8, 1, 8, 9, 1, -1 ],
            [ 5, 2, 10, 5, 3, 2, 5, 7, 3, -1 ],
            [ 5, 7, 10, 7, 8, 0, 10, 7, 0, 10, 0, 2, -1 ],
            [ 0, 9, 1, 5, 2, 10, 5, 3, 2, 5, 7, 3, -1 ],
            [ 9, 7, 8, 5, 7, 9, 10, 1, 2, -1 ],
            [ 1, 11, 2, 1, 7, 11, 1, 5, 7, -1 ],
            [ 8, 0, 3, 1, 11, 2, 1, 7, 11, 1, 5, 7, -1 ],
            [ 7, 11, 2, 7, 2, 9, 2, 0, 9, 5, 7, 9, -1 ],
            [ 7, 9, 5, 8, 9, 7, 3, 11, 2, -1 ],
            [ 3, 1, 7, 7, 1, 5, -1 ],
            [ 8, 0, 7, 0, 1, 7, 1, 5, 7, -1 ],
            [ 0, 9, 3, 9, 5, 3, 5, 7, 3, -1 ],
            [ 9, 7, 8, 5, 7, 9, -1 ],
            [ 8, 5, 4, 8, 10, 5, 8, 11, 10, -1 ],
            [ 0, 3, 11, 0, 11, 5, 11, 10, 5, 4, 0, 5, -1 ],
            [ 1, 0, 9, 8, 5, 4, 8, 10, 5, 8, 11, 10, -1 ],
            [ 10, 3, 11, 1, 3, 10, 9, 5, 4, -1 ],
            [ 3, 2, 8, 8, 2, 4, 4, 2, 10, 4, 10, 5, -1 ],
            [ 10, 5, 2, 5, 4, 2, 4, 0, 2, -1 ],
            [ 5, 4, 9, 8, 3, 0, 10, 1, 2, -1 ],
            [ 2, 10, 1, 4, 9, 5, -1 ],
            [ 8, 11, 4, 11, 2, 1, 4, 11, 1, 4, 1, 5, -1 ],
            [ 0, 5, 4, 1, 5, 0, 2, 3, 11, -1 ],
            [ 0, 11, 2, 8, 11, 0, 4, 9, 5, -1 ],
            [ 5, 4, 9, 2, 3, 11, -1 ],
            [ 4, 8, 5, 8, 3, 5, 3, 1, 5, -1 ],
            [ 0, 5, 4, 1, 5, 0, -1 ],
            [ 5, 4, 9, 3, 0, 8, -1 ],
            [ 5, 4, 9, -1 ],
            [ 11, 4, 7, 11, 9, 4, 11, 10, 9, -1 ],
            [ 0, 3, 8, 11, 4, 7, 11, 9, 4, 11, 10, 9, -1 ],
            [ 11, 10, 7, 10, 1, 0, 7, 10, 0, 7, 0, 4, -1 ],
            [ 3, 10, 1, 11, 10, 3, 7, 8, 4, -1 ],
            [ 3, 2, 10, 3, 10, 4, 10, 9, 4, 7, 3, 4, -1 ],
            [ 9, 2, 10, 0, 2, 9, 8, 4, 7, -1 ],
            [ 3, 4, 7, 0, 4, 3, 1, 2, 10, -1 ],
            [ 7, 8, 4, 10, 1, 2, -1 ],
            [ 7, 11, 4, 4, 11, 9, 9, 11, 2, 9, 2, 1, -1 ],
            [ 1, 9, 0, 4, 7, 8, 2, 3, 11, -1 ],
            [ 7, 11, 4, 11, 2, 4, 2, 0, 4, -1 ],
            [ 4, 7, 8, 2, 3, 11, -1 ],
            [ 9, 4, 1, 4, 7, 1, 7, 3, 1, -1 ],
            [ 7, 8, 4, 1, 9, 0, -1 ],
            [ 3, 4, 7, 0, 4, 3, -1 ],
            [ 7, 8, 4, -1 ],
            [ 11, 10, 8, 8, 10, 9, -1 ],
            [ 0, 3, 9, 3, 11, 9, 11, 10, 9, -1 ],
            [ 1, 0, 10, 0, 8, 10, 8, 11, 10, -1 ],
            [ 10, 3, 11, 1, 3, 10, -1 ],
            [ 3, 2, 8, 2, 10, 8, 10, 9, 8, -1 ],
            [ 9, 2, 10, 0, 2, 9, -1 ],
            [ 8, 3, 0, 10, 1, 2, -1 ],
            [ 2, 10, 1, -1 ],
            [ 2, 1, 11, 1, 9, 11, 9, 8, 11, -1 ],
            [ 11, 2, 3, 9, 0, 1, -1 ],
            [ 11, 0, 8, 2, 0, 11, -1 ],
            [ 3, 11, 2, -1 ],
            [ 1, 8, 3, 9, 8, 1, -1 ],
            [ 1, 9, 0, -1 ],
            [ 8, 3, 0, -1 ],
            [ -1 ],
        ];


        // Marching Cubes utility function
        function generateMarchingCubesGeometry(grid, threshold, gridSize, blockSize) {
            const vertices = [];
            const normals = [];
            const indices = [];
            const resolution = gridSize; // Marching Cubes operates on a grid

            // Function to get interpolated vertex position
            function interpolateVertex(p1, p2, val1, val2, threshold) {
                const mu = (threshold - val1) / (val2 - val1);
                return new THREE.Vector3(
                    p1.x + mu * (p2.x - p1.x),
                    p1.y + mu * (p2.y - p1.y),
                    p1.z + mu * (p2.z - p1.z)
                );
            }

            // Iterate over each cell in the grid
            for (let x = 0; x < resolution - 1; x++) {
                for (let y = 0; y < resolution - 1; y++) {
                    for (let z = 0; z < resolution - 1; z++) {
                        // Get the 8 corner values of the current cube
                        const cubeValues = new Array(8);
                        const cubeCorners = new Array(8); // Store actual 3D positions of corners

                        for (let i = 0; i < 8; i++) {
                            const x_offset = (i & 1) >> 0;
                            const y_offset = (i & 2) >> 1;
                            const z_offset = (i & 4) >> 2;

                            // Ensure we don't go out of bounds when accessing grid
                            const gx = x + x_offset;
                            const gy = y + y_offset;
                            const gz = z + z_offset;

                            // Handle boundary conditions for grid access
                            if (gx >= resolution || gy >= resolution || gz >= resolution) {
                                // This should ideally not happen with resolution - 1 loop limit,
                                // but as a safety for indexing cubeValues.
                                continue;
                            }

                            cubeValues[i] = grid[gx][gy][gz];
                            cubeCorners[i] = new THREE.Vector3(
                                (gx - gridSize / 2 + 0.5) * blockSize,
                                (gy - gridSize / 2 + 0.5) * blockSize,
                                (gz - gridSize / 2 + 0.5) * blockSize
                            );
                        }

                        // Determine the cube index from the thresholded values
                        let cubeIndex = 0;
                        if (cubeValues[0] < threshold) cubeIndex |= 1;
                        if (cubeValues[1] < threshold) cubeIndex |= 2;
                        if (cubeValues[2] < threshold) cubeIndex |= 4;
                        if (cubeValues[3] < threshold) cubeIndex |= 8;
                        if (cubeValues[4] < threshold) cubeIndex |= 16;
                        if (cubeValues[5] < threshold) cubeIndex |= 32;
                        if (cubeValues[6] < threshold) cubeIndex |= 64;
                        if (cubeValues[7] < threshold) cubeIndex |= 128;

                        // Get the triangulation case from TriangleTable
                        const triangles = TriangleTable[cubeIndex];

                        // Generate triangles
                        for (let i = 0; triangles[i] !== -1; i += 3) {
                            const edge1Index = triangles[i];
                            const edge2Index = triangles[i + 1];
                            const edge3Index = triangles[i + 2];

                            const v1a = EdgeVertexIndices[edge1Index][0];
                            const v1b = EdgeVertexIndices[edge1Index][1];
                            const v2a = EdgeVertexIndices[edge2Index][0];
                            const v2b = EdgeVertexIndices[edge2Index][1];
                            const v3a = EdgeVertexIndices[edge3Index][0];
                            const v3b = EdgeVertexIndices[edge3Index][1];

                            const p1 = interpolateVertex(cubeCorners[v1a], cubeCorners[v1b], cubeValues[v1a], cubeValues[v1b], threshold);
                            const p2 = interpolateVertex(cubeCorners[v2a], cubeCorners[v2b], cubeValues[v2a], cubeValues[v2b], threshold);
                            const p3 = interpolateVertex(cubeCorners[v3a], cubeCorners[v3b], cubeValues[v3a], cubeValues[v3b], threshold);

                            const currentVertexCount = vertices.length / 3;

                            vertices.push(p1.x, p1.y, p1.z);
                            vertices.push(p2.x, p2.y, p2.z);
                            vertices.push(p3.x, p3.y, p3.z);

                            indices.push(currentVertexCount, currentVertexCount + 1, currentVertexCount + 2);

                            // Calculate face normal
                            const cb = new THREE.Vector3().subVectors(p3, p2);
                            const ab = new THREE.Vector3().subVectors(p1, p2);
                            const normal = new THREE.Vector3().crossVectors(cb, ab).normalize();

                            normals.push(normal.x, normal.y, normal.z);
                            normals.push(normal.x, normal.y, normal.z);
                            normals.push(normal.x, normal.y, normal.z);
                        }
                    }
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3)); // For lighting calculations
            geometry.setIndex(indices);
            geometry.computeVertexNormals(); // Recalculate normals for smoother appearance

            return geometry;
        }

        // Set up basic Three.js scene components
        let scene, camera, renderer, raycaster;
        let marchingCubesMesh, marchingCubesMeshMoon; // Meshes for planet and moon
        let playerDebugMesh; // Visual representation of the player for debugging

        // Player variables
        const player = {
            position: new THREE.Vector3(),
            velocity: new THREE.Vector3(),
            height: 1.75, // Player height in world units
            onGround: false,
            rotation: {
                yaw: 0,   // Y-axis rotation (left/right)
                pitch: 0, // X-axis rotation (up/down)
            },
            movementSpeed: 0.08,
            gravityStrength: 0.005,
            jumpStrength: 0.32, // Increased for moon jump capability
            sensitivity: 0.002 // Mouse/touch look sensitivity
        };

        const keys = { w: false, a: false, s: false, d: false, space: false };
        const planetCenter = new THREE.Vector3(0, 0, 0); // Center of the planet

        let isLocked = false; // Pointer lock state for desktop
        let mobileLookTouchId = -1; // Track active touch for mobile look
        let mobileJoystickTouchId = -1; // Track active touch for mobile joystick
        let joystickCenter = new THREE.Vector2(); // Center of the joystick base
        const joystickRadius = 50; // Radius of the joystick base

        // Voxel grid properties
        const GRID_SIZE = 100; // Diameter of the planet in blocks
        const BLOCK_SIZE = 1; // Logical size of each individual block for scaling
        const PLANET_RADIUS_FACTOR = 0.8; // Adjust to make the initial sphere larger/smaller within the grid
        const ISO_LEVEL = 0.5; // Isosurface threshold for Marching Cubes

        // Moon properties
        const GRID_SIZE_MOON = 20; // Diameter of the moon in blocks
        const MOON_RADIUS_FACTOR = 0.9; // Moon's radius within its grid
        const MOON_ORBIT_DISTANCE = GRID_SIZE * BLOCK_SIZE * 0.75; // Distance from planet center
        //const ISO_LEVEL = 0.5; // Isosurface threshold for Marching Cubes

        // A 3D array to represent the voxel data (density values)
        let voxelData = [];

        // DOM Elements
        const overlay = document.getElementById('overlay');
        let voxelDataMoon = [];
        let moonPosition = new THREE.Vector3(); // To store the moon's world position
        const messageBox = document.getElementById('message-box');
        let canvas; // Declare canvas here, initialize in init()
        const joystickBase = document.getElementById('joystick-base');
        const joystickThumb = document.getElementById('joystick-thumb');
        const mineButton = document.getElementById('mine-button');
        const mobileControls = document.getElementById('mobile-controls');


        /**
         * Initializes the Three.js scene, camera, renderer, and lighting.
         * Sets up event listeners for user interaction and window resizing.
         */
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x282c34); // Dark background

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            // Initial camera position will be set after generating the planet
            camera.rotation.order = 'YXZ'; // Important for FPS-style rotations (yaw then pitch)

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Initialize canvas here, where the DOM is guaranteed to be ready and after it's appended
            canvas = renderer.domElement;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 2); // Soft white light
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5); // Stronger directional light
            directionalLight.position.set(5, 5, 5).normalize();
            scene.add(directionalLight);

            // Raycaster for mining and ground detection
            raycaster = new THREE.Raycaster();

            // Generate the initial planet using Marching Cubes
            generatePlanet();

            // Generate the moon
            generateMoon();


            // Place player on the surface after planet generation
            placePlayerOnSurface();

            // Force initial grounding to prevent falling through at start
            const playerUpInitial = player.position.clone().normalize();
            const gravityDirectionInitial = planetCenter.clone().sub(player.position).normalize();
            const rayOriginInitial = player.position.clone().add(playerUpInitial.clone().multiplyScalar(-player.height * 0.5));
            raycaster.set(rayOriginInitial, gravityDirectionInitial);
            const intersectsInitial = raycaster.intersectObjects([marchingCubesMesh]);
            if (intersectsInitial.length > 0) {
                const hitPointInitial = intersectsInitial[0].point;
                const snapOffsetInitial = 0.01; // Same as in animate loop
                player.position.copy(hitPointInitial.clone().add(playerUpInitial.clone().multiplyScalar(player.height * 0.5 + snapOffsetInitial)));
                player.onGround = true;
                player.velocity.set(0, 0, 0); // Ensure no initial velocity
            } else {
                console.warn("Initial player placement: Could not find ground beneath player.");
            }

            // Event Listeners for desktop (keyboard & mouse lock)
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('pointerlockchange', onPointerLockChange);

            // Overlay for initial click to enable pointer lock
            overlay.addEventListener('click', () => {
                if (!isLocked) {
                    canvas.requestPointerLock();
                }
            });

            // Mobile control setup
            if (isMobileDevice()) {
                mobileControls.style.display = 'flex'; // Show mobile controls
                setupMobileControls();
                messageBox.textContent = "Tap joystick to move, drag right side to look, tap MINE to dig!";
            } else {
                mobileControls.style.display = 'none'; // Hide mobile controls
                messageBox.textContent = "WASD to move, Mouse to look, Click to dig planet/moon!";
            }
            // Global window resize listener
            window.addEventListener('resize', onWindowResize);

            // Setup player debug mesh
            setupPlayerDebugMesh();
        }

        /**
         * Checks if the device is likely mobile based on user agent and touch capabilities.
         * @returns {boolean} True if likely a mobile device.
         */
        function isMobileDevice() {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            return /android|iphone|ipad|ipod|blackberry|windows phone/i.test(userAgent) ||
                   ('ontouchstart' in window) ||
                   (navigator.maxTouchPoints > 0) ||
                   (navigator.msMaxTouchPoints > 0);
        }

        /**
         * Sets up touch listeners for mobile controls.
         */
        function setupMobileControls() {
            // Joystick
            joystickBase.addEventListener('touchstart', onJoystickStart, { passive: false });
            document.addEventListener('touchmove', onJoystickMove, { passive: false });
            document.addEventListener('touchend', onJoystickEnd, { passive: false });

            // Look
            document.addEventListener('touchstart', onTouchStartLook, { passive: false });
            document.addEventListener('touchmove', onTouchMoveLook, { passive: false });
            document.addEventListener('touchend', onTouchEndLook, { passive: false });

            // Mine Button
            mineButton.addEventListener('click', onMineButtonClick); // Regular click for button
        }

        /**
         * Sets up a visual representation for the player (block legs/body).
         */
        function setupPlayerDebugMesh() {
            const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
            const feetMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });

            // Body: Positioned relative to player.position (which is head/camera height)
            const bodyHeight = player.height * 0.6;
            const bodyGeometry = new THREE.BoxGeometry(0.4, bodyHeight, 0.25);
            const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            bodyMesh.position.y = -player.height * 0.2; // Center of body below head

            // Feet: Positioned at the bottom of the player
            const feetHeight = 0.2;
            const feetGeometry = new THREE.BoxGeometry(0.45, feetHeight, 0.3);
            const feetMesh = new THREE.Mesh(feetGeometry, feetMaterial);
            feetMesh.position.y = -player.height * 0.5 + feetHeight * 0.5; // Feet mesh bottom aligns with player bottom

            playerDebugMesh = new THREE.Group();
            playerDebugMesh.add(bodyMesh);
            playerDebugMesh.add(feetMesh);
            scene.add(playerDebugMesh);
            playerDebugMesh.visible = false; // Start with the debug mesh hidden
        }


        /**
         * Handles touch start for joystick.
         * @param {TouchEvent} event - The touchstart event.
         */
        function onJoystickStart(event) {
            event.preventDefault(); // Prevent scrolling on some devices
            if (mobileJoystickTouchId === -1) { // Only start if no joystick touch is active
                const touch = event.changedTouches[0];
                const rect = joystickBase.getBoundingClientRect();
                joystickCenter.set(rect.left + rect.width / 2, rect.top + rect.height / 2);
                joystickThumb.style.left = (touch.clientX - joystickCenter.x + joystickRadius) + 'px';
                joystickThumb.style.top = (touch.clientY - joystickCenter.y + joystickRadius) + 'px';
                mobileJoystickTouchId = touch.identifier;
            }
        }

        /**
         * Handles touch move for joystick.
         * @param {TouchEvent} event - The touchmove event.
         */
        function onJoystickMove(event) {
            event.preventDefault(); // Prevent scrolling
            for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];
                if (touch.identifier === mobileJoystickTouchId) {
                    let dx = touch.clientX - joystickCenter.x;
                    let dy = touch.clientY - joystickCenter.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > joystickRadius) {
                        dx *= joystickRadius / distance;
                        dy *= joystickRadius / distance;
                    }

                    joystickThumb.style.left = (dx + joystickRadius) + 'px';
                    joystickThumb.style.top = (dy + joystickRadius) + 'px';

                    // Update keys for movement
                    keys.w = dy < -20;
                    keys.s = dy > 20;
                    keys.a = dx < -20;
                    keys.d = dx > 20;
                }
            }
        }

        /**
         * Handles touch end for joystick.
         * @param {TouchEvent} event - The touchend event.
         */
        function onJoystickEnd(event) {
            for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];
                if (touch.identifier === mobileJoystickTouchId) {
                    joystickThumb.style.left = '';
                    joystickThumb.style.top = '';
                    mobileJoystickTouchId = -1;
                    keys.w = keys.a = keys.s = keys.d = false; // Reset movement keys
                }
            }
        }

        /**
         * Handles touch start for camera look.
         * @param {TouchEvent} event - The touchstart event.
         */
        function onTouchStartLook(event) {
            // If it's a multi-touch, or if joystick touch is active, ignore.
            // If it's the first touch and not on joystick/mine button, capture for look.
            if (event.touches.length === 1 && mobileJoystickTouchId === -1 && mobileLookTouchId === -1) {
                // Check if the touch started on the right half of the screen
                if (event.touches[0].clientX > window.innerWidth / 2) {
                    mobileLookTouchId = event.touches[0].identifier;
                    player.previousClientX = event.touches[0].clientX;
                    player.previousClientY = event.touches[0].clientY;
                }
            }
        }

        /**
         * Handles touch move for camera look.
         * @param {TouchEvent} event - The touchmove event.
         */
        function onTouchMoveLook(event) {
            for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];
                if (touch.identifier === mobileLookTouchId) {
                    const deltaX = touch.clientX - player.previousClientX;
                    const deltaY = touch.clientY - player.previousClientY;

                    player.rotation.yaw -= deltaX * player.sensitivity;
                    player.rotation.pitch -= deltaY * player.sensitivity;

                    // Clamp pitch to prevent flipping
                    player.rotation.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.rotation.pitch));

                    player.previousClientX = touch.clientX;
                    player.previousClientY = touch.clientY;
                }
            }
        }

        /**
         * Handles touch end for camera look.
         * @param {TouchEvent} event - The touchend event.
         */
        function onTouchEndLook(event) {
            for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];
                if (touch.identifier === mobileLookTouchId) {
                    mobileLookTouchId = -1;
                }
            }
        }

        /**
         * Handles click on the mine button.
         */
        function onMineButtonClick() {
            mineBlockAtCrosshair();
        }

        /**
         * Places the player on the surface of the planet.
         */
        function placePlayerOnSurface() {
            const planetRadius = GRID_SIZE / 2 * BLOCK_SIZE * PLANET_RADIUS_FACTOR;
            player.position.set(0, planetRadius + player.height / 2, 0); // Start player above the "north pole"
            camera.position.copy(player.position);
            camera.lookAt(planetCenter); // Initially look at the center of the planet
        }

        /**
         * Handles keyboard key presses.
         * @param {KeyboardEvent} event - The keyboard event.
         */
        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': keys.w = true; break;
                case 'KeyA': keys.a = true; break;
                case 'KeyS': keys.s = true; break;
                case 'KeyD': keys.d = true; break;
                case 'Space':
                    if (player.onGround) {
                        // Determine "up" direction relative to the planet's center
                        const upDirection = player.position.clone().normalize();
                        player.velocity.add(upDirection.multiplyScalar(player.jumpStrength));
                        player.onGround = false; // Player is now in the air
                    }
                    keys.space = true; // Keep track of space key down
                    break;
                case 'KeyP':
                    if (playerDebugMesh) {
                        playerDebugMesh.visible = !playerDebugMesh.visible;
                    }
                    break;
            }
        }

        /**
         * Handles keyboard key releases.
         * @param {KeyboardEvent} event - The keyboard event.
         */
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': keys.w = false; break;
                case 'KeyA': keys.a = false; break;
                case 'KeyS': keys.s = false; break;
                case 'KeyD': keys.d = false; break;
                case 'Space': keys.space = false; break;
            }
        }

        /**
         * Handles mouse movement for camera look when pointer is locked.
         * @param {MouseEvent} event - The mouse event.
         */
        function onMouseMove(event) {
            if (isLocked) {
                const deltaX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                const deltaY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

                player.rotation.yaw -= deltaX * player.sensitivity;
                player.rotation.pitch -= deltaY * player.sensitivity;

                // Clamp pitch to prevent flipping the camera upside down
                player.rotation.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.rotation.pitch));
            }
        }

        /**
         * Handles pointer lock state changes.
         */
        function onPointerLockChange() {
            if (document.pointerLockElement === renderer.domElement) {
                isLocked = true;
                overlay.style.display = 'none';
                messageBox.style.display = 'block'; // Show message box when locked
                messageBox.textContent = "WASD to move, Mouse to look, Click to dig planet/moon!";
            } else {
                isLocked = false;
                overlay.style.display = 'flex';
                messageBox.style.display = 'none'; // Hide message box when unlocked
            }
        }

        /**
         * Mines a block at the crosshair's target.
         */
        function mineBlockAtCrosshair() {
            // Set raycaster from camera's perspective, pointing forward
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera); // (0,0) is center of screen

            // Check for intersections with the marching cubes mesh
            const intersects = raycaster.intersectObjects([marchingCubesMesh, marchingCubesMeshMoon].filter(mesh => mesh)); // Filter out undefined meshes

            if (intersects.length > 0) {
                const intersectionPoint = intersects[0].point;
                const intersectedObject = intersects[0].object;
                const miningRayDir = raycaster.ray.direction;
                const offsetWorldPoint = intersectionPoint.clone().add(miningRayDir.clone().multiplyScalar(-BLOCK_SIZE * 0.25)); // Offset slightly into the surface

                if (intersectedObject === marchingCubesMesh) {
                    // Hit the planet
                    const halfGridPlanet = GRID_SIZE / 2;
                    const gridX = Math.floor(offsetWorldPoint.x / BLOCK_SIZE + halfGridPlanet);
                    const gridY = Math.floor(offsetWorldPoint.y / BLOCK_SIZE + halfGridPlanet);
                    const gridZ = Math.floor(offsetWorldPoint.z / BLOCK_SIZE + halfGridPlanet);

                    if (gridX >= 0 && gridX < GRID_SIZE &&
                        gridY >= 0 && gridY < GRID_SIZE &&
                        gridZ >= 0 && gridZ < GRID_SIZE) {
                        mineBlock(gridX, gridY, gridZ, 'planet', intersectionPoint);
                    }
                } else if (intersectedObject === marchingCubesMeshMoon) {
                    // Hit the moon
                    const localOffsetPointForMoon = offsetWorldPoint.clone().sub(marchingCubesMeshMoon.position);
                    const halfGridMoon = GRID_SIZE_MOON / 2;

                    const gridX = Math.floor(localOffsetPointForMoon.x / BLOCK_SIZE + halfGridMoon);
                    const gridY = Math.floor(localOffsetPointForMoon.y / BLOCK_SIZE + halfGridMoon);
                    const gridZ = Math.floor(localOffsetPointForMoon.z / BLOCK_SIZE + halfGridMoon);

                    if (gridX >= 0 && gridX < GRID_SIZE_MOON &&
                        gridY >= 0 && gridY < GRID_SIZE_MOON &&
                        gridZ >= 0 && gridZ < GRID_SIZE_MOON) {
                        mineBlock(gridX, gridY, gridZ, 'moon', intersectionPoint);
                    }
                }
            }
        }


        /**
         * Generates the initial voxel data for a spherical planet.
         * Then calls updateMarchingCubesMesh to create the mesh.
         */
        function generatePlanet() {
            // Initialize voxelData with density values
            for (let x = 0; x < GRID_SIZE; x++) {
                voxelData[x] = [];
                for (let y = 0; y < GRID_SIZE; y++) {
                    voxelData[x][y] = [];
                    for (let z = 0; z < GRID_SIZE; z++) {
                        // Calculate distance from the center of the grid (normalized to 0-1 range)
                        const center = GRID_SIZE / 2;
                        const dx = (x - center + 0.5); // +0.5 to center the sampling point in the voxel
                        const dy = (y - center + 0.5);
                        const dz = (z - center + 0.5);

                        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        const normalizedDist = dist / (GRID_SIZE / 2 * PLANET_RADIUS_FACTOR);

                        // Use a smooth falloff function for density
                        // Density is 1 (solid) near the center, 0 (empty) outside the radius
                        voxelData[x][y][z] = Math.max(0, 1 - normalizedDist);
                    }
                }
            }
            updateMarchingCubesMesh();
        }

        /**
         * Generates the voxel data and mesh for the moon.
         */
        function generateMoon() {
            // Calculate moon's position (opposite to main light direction)
            const lightDirForMoonPlacement = new THREE.Vector3(1, 1, 1).normalize(); // Arbitrary direction for main light source for placement
            moonPosition.copy(lightDirForMoonPlacement).negate().setLength(MOON_ORBIT_DISTANCE);

            // Initialize moonVoxelData
            for (let x = 0; x < GRID_SIZE_MOON; x++) {
                voxelDataMoon[x] = [];
                for (let y = 0; y < GRID_SIZE_MOON; y++) {
                    voxelDataMoon[x][y] = [];
                    for (let z = 0; z < GRID_SIZE_MOON; z++) {
                        const center = GRID_SIZE_MOON / 2;
                        const dx = (x - center + 0.5);
                        const dy = (y - center + 0.5);
                        const dz = (z - center + 0.5);
                        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        const normalizedDist = dist / (GRID_SIZE_MOON / 2 * MOON_RADIUS_FACTOR);
                        voxelDataMoon[x][y][z] = Math.max(0, 1 - normalizedDist);
                    }
                }
            }
            updateMarchingCubesMoonMesh();
        }


        /**
         * Updates the Three.js mesh based on the current voxelData using Marching Cubes.
         */
        function updateMarchingCubesMesh() {
            // Remove the old mesh if it exists
            if (marchingCubesMesh) {
                scene.remove(marchingCubesMesh);
                marchingCubesMesh.geometry.dispose();
                marchingCubesMesh.material.dispose();
            }

            // Generate new geometry using Marching Cubes
            const geometry = generateMarchingCubesGeometry(voxelData, ISO_LEVEL, GRID_SIZE, BLOCK_SIZE);
            const material = new THREE.MeshStandardMaterial({
                color: 0x5a2d0a, // Earthy brown color
                roughness: 0.7,
                metalness: 0.2,
                side: THREE.DoubleSide // Important for enclosed volumes, though Marching Cubes typically handles normals
            });

            marchingCubesMesh = new THREE.Mesh(geometry, material);
            scene.add(marchingCubesMesh);
        }

        /**
         * Updates the Three.js mesh for the moon.
         */
        function updateMarchingCubesMoonMesh() {
            if (marchingCubesMeshMoon) {
                scene.remove(marchingCubesMeshMoon);
                if (marchingCubesMeshMoon.geometry) marchingCubesMeshMoon.geometry.dispose();
                if (marchingCubesMeshMoon.material) marchingCubesMeshMoon.material.dispose();
                // Remove light if it was a child
                const oldLight = marchingCubesMeshMoon.getObjectByName("moonLightSource");
                if (oldLight) marchingCubesMeshMoon.remove(oldLight);
            }

            const geometry = generateMarchingCubesGeometry(voxelDataMoon, ISO_LEVEL, GRID_SIZE_MOON, BLOCK_SIZE);
            const material = new THREE.MeshStandardMaterial({
                color: 0xcccccc, // Lighter grey for moon
                emissive: 0x111133, // Faint blueish self-glow
                roughness: 0.9,
                metalness: 0.1,
                side: THREE.DoubleSide
            });
            marchingCubesMeshMoon = new THREE.Mesh(geometry, material);
            marchingCubesMeshMoon.position.copy(moonPosition);
            scene.add(marchingCubesMeshMoon);

            // Add blueish light to the moon
            const moonLight = new THREE.PointLight(0x6080ff, 0.6, MOON_ORBIT_DISTANCE * 1.2, 1.5); // color, intensity, distance, decay
            moonLight.name = "moonLightSource";
            // Position light at the center of the moon mesh (which is already at moonPosition)
            marchingCubesMeshMoon.add(moonLight); // Add light as child of moon mesh
        }


        /**
         * Mines a specific "block" in the voxel data, setting its density to 0.
         * Then regenerates the Marching Cubes mesh.
         * @param {number} gridX - X coordinate in the voxel grid.
         * @param {number} gridY - Y coordinate in the voxel grid.
         * @param {number} gridZ - Z coordinate in the voxel grid.
         * @param {string} targetType - 'planet' or 'moon'.
         * @param {THREE.Vector3} effectWorldPosition - The world position for the mining effect.
         */
        function mineBlock(gridX, gridY, gridZ, targetType, effectWorldPosition) {
            if (targetType === 'planet') {
                voxelData[gridX][gridY][gridZ] = 0;
                updateMarchingCubesMesh();
            } else if (targetType === 'moon') {
                voxelDataMoon[gridX][gridY][gridZ] = 0;
                updateMarchingCubesMoonMesh();
            }
            createMiningEffect(effectWorldPosition, targetType);
        }

        /**
         * Creates a small visual effect at the mining location.
         * @param {THREE.Vector3} position - The world position where mining occurred.
         * @param {string} minedObjectType - 'planet' or 'moon', to determine particle color.
         */
        function createMiningEffect(position, minedObjectType) {
            const particleCount = 10;
            const particleGeometry = new THREE.SphereGeometry(0.05, 6, 6); // Slightly less detail for performance

            let baseParticleColor = 0xffa500; // Default orange/yellow
            let sparkColor = 0xffffff; // Default white spark

            if (minedObjectType === 'planet') {
                baseParticleColor = 0x5a2d0a; // Brownish, like the planet
                sparkColor = 0xffd700; // Gold spark for planet
            } else if (minedObjectType === 'moon') {
                baseParticleColor = 0xcccccc; // Greyish, like the moon
                sparkColor = 0x00ffff; // Cyan spark for moon
            }

            const particleMaterial = new THREE.MeshBasicMaterial({ color: baseParticleColor });

            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(position);

                // Give random velocity
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 0.5
                );
                particle.decay = 0.02; // How fast the particle fades/shrinks

                scene.add(particle);

                // Animate particle removal after a short time
                let opacity = 1;
                const interval = setInterval(() => {
                    if (opacity <= 0) {
                        scene.remove(particle);
                        clearInterval(interval);
                    } else {
                        particle.position.add(particle.velocity);
                        particle.material.opacity = opacity;
                        particle.material.transparent = true;
                        particle.scale.multiplyScalar(0.95); // Shrink
                        opacity -= particle.decay;
                    }
                }, 50);
            }

            // Add a single, special spark
            const sparkGeometry = new THREE.TetrahedronGeometry(0.1, 0); // size, detail
            const sparkMaterial = new THREE.MeshBasicMaterial({ color: sparkColor, emissive: sparkColor, emissiveIntensity: 0.5 });
            const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
            spark.position.copy(position);
            spark.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.6, // Slightly faster/more erratic
                (Math.random() * 0.3 + 0.3) * 0.6, // Bias upwards
                (Math.random() - 0.5) * 0.6
            );
            spark.decay = 0.015; // Spark lasts a bit longer
            spark.rotationSpeed = new THREE.Vector3(
                (Math.random() - 0.5) * 0.2,
                (Math.random() - 0.5) * 0.2,
                (Math.random() - 0.5) * 0.2
            );
            scene.add(spark);

            let sparkOpacity = 1;
            const sparkInterval = setInterval(() => {
                if (sparkOpacity <= 0) {
                    scene.remove(spark);
                    clearInterval(sparkInterval);
                } else {
                    spark.position.add(spark.velocity);
                    spark.rotation.x += spark.rotationSpeed.x;
                    spark.rotation.y += spark.rotationSpeed.y;
                    spark.rotation.z += spark.rotationSpeed.z;
                    spark.material.opacity = sparkOpacity;
                    spark.material.transparent = true;
                    spark.scale.multiplyScalar(0.96);
                    sparkOpacity -= spark.decay;
                }
            }, 50);
        }

        /**
         * Handles window resizing to maintain responsiveness.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Update joystick center if mobile controls are visible
            if (isMobileDevice()) {
                const rect = joystickBase.getBoundingClientRect();
                joystickCenter.set(rect.left + rect.width / 2, rect.top + rect.height / 2);
            }
        }

        /**
         * The main animation loop for rendering the scene and updating player state.
         */
        function animate() {
            requestAnimationFrame(animate);

            // Apply camera rotations
            camera.rotation.y = player.rotation.yaw;
            camera.rotation.x = player.rotation.pitch;

            // Player's "up" direction (away from planet center)
            const playerUp = player.position.clone().normalize();

            // Calculate desired horizontal velocity based on input
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward); // Get camera's forward direction
            const gravityPlaneNormal = playerUp; // For movement relative to surface
            const movementDirection = forward.clone().projectOnPlane(gravityPlaneNormal).normalize();
            const right = new THREE.Vector3().crossVectors(playerUp, movementDirection).normalize();
            // Note: The original 'right' vector was playerUp.cross(movementDirection), which is "left".
            // The current 'right' is playerUp.cross(movementDirection.negate()) or movementDirection.cross(playerUp)
            // Corrected right vector: movementDirection x playerUp (forward x up)
            right.crossVectors(movementDirection, playerUp);

            let desiredHorizontalVelocity = new THREE.Vector3(0, 0, 0);
            if (keys.w) desiredHorizontalVelocity.add(movementDirection);
            if (keys.s) desiredHorizontalVelocity.sub(movementDirection);
            if (keys.a) desiredHorizontalVelocity.sub(right); // Strafe left
            if (keys.d) desiredHorizontalVelocity.add(right); // Strafe right

            if (desiredHorizontalVelocity.lengthSq() > 0) {
                desiredHorizontalVelocity.normalize().multiplyScalar(player.movementSpeed);
            }

            // Decompose current player.velocity into horizontal and vertical components relative to playerUp
            const verticalVelocityScalar = player.velocity.dot(playerUp);
            const currentVerticalComponent = playerUp.clone().multiplyScalar(verticalVelocityScalar);
            const currentHorizontalComponent = player.velocity.clone().sub(currentVerticalComponent);

            // LERP the horizontal component towards the desired horizontal velocity
            currentHorizontalComponent.lerp(desiredHorizontalVelocity, 0.2); // Increased LERP factor for snappier horizontal movement

            // Reconstruct player.velocity: LERPed horizontal + original vertical (gravity/jump affect this part)
            player.velocity.copy(currentHorizontalComponent).add(currentVerticalComponent);

            // Player's "up" direction (away from planet center)
            // This is already defined as playerUp, but re-calculate here for clarity within physics.
            // Direction towards planet center (gravity direction)
            const gravityDirection = planetCenter.clone().sub(player.position).normalize();

            // Apply gravity
            if (!player.onGround) { // Apply gravity only when airborne
                player.velocity.add(gravityDirection.multiplyScalar(player.gravityStrength));
            }

            // Raycast for ground detection
            // Ray starts from player's feet and points towards the planet's core
            const rayOrigin = player.position.clone().add(playerUp.clone().multiplyScalar(-player.height * 0.5)); // Start at player's feet
            raycaster.set(rayOrigin, gravityDirection); // Point towards the center of the planet

            const intersects = raycaster.intersectObjects([marchingCubesMesh, marchingCubesMeshMoon].filter(mesh => mesh));

            // Assume not on ground until confirmed
            player.onGround = false;

            if (intersects.length > 0) {
                const hitPoint = intersects[0].point;
                const distanceToHitPoint = rayOrigin.distanceTo(hitPoint);

                // groundDetectionTolerance should be small enough that a jump impulse lifts the player
                // out of this range in one frame, but larger than snapOffset.
                // Given jumpStrength = 0.1, gravity = 0.005, net_up_1_frame = 0.095.
                const groundDetectionTolerance = 0.05; // How far above the surface we consider "on ground"

                // Check if player is close to ground AND not moving upwards too fast (i.e., not in the middle of a jump)
                const verticalSpeed = player.velocity.dot(playerUp); // Positive if moving up, negative if moving down
                const upwardSpeedThreshold = 0.05; // If moving up faster than this, don't re-ground even if close

                if (distanceToHitPoint < groundDetectionTolerance && verticalSpeed < upwardSpeedThreshold) {
                    player.onGround = true;

                    // Snap player to the surface
                    const snapOffset = 0.01; // Small offset to prevent sinking and improve stability
                    player.position.copy(hitPoint.clone().add(playerUp.clone().multiplyScalar(player.height * 0.5 + snapOffset)));

                    // Remove the vertical component of velocity (relative to the ground normal)
                    // This prevents bouncing and ensures smooth standing on the surface.
                    const verticalVelocityComponent = playerUp.clone().multiplyScalar(player.velocity.dot(playerUp));
                    player.velocity.sub(verticalVelocityComponent);
                }
            }

            // If still not on ground after downward check, try an upward correction.
            // This handles cases where the player might have fallen through/into the surface.
            if (!player.onGround && (marchingCubesMesh || marchingCubesMeshMoon)) {
                const rayOriginUpward = player.position.clone(); // Ray from player's head
                const rayDirectionUpward = playerUp.clone();     // Directly "up" relative to player (away from planet center)

                raycaster.set(rayOriginUpward, rayDirectionUpward);
                const intersectsUpward = raycaster.intersectObjects([marchingCubesMesh, marchingCubesMeshMoon].filter(mesh => mesh));
                
                if (intersectsUpward.length > 0) {
                    const hitPointUpward = intersectsUpward[0].point; // This is the "ceiling" point
                    const distanceToHitPointUpward = rayOriginUpward.distanceTo(hitPointUpward);

                    // If a surface is detected very close *above* the player's head,
                    // it means the player's head is below or inside that surface.
                    const upwardCorrectionTriggerDistance = player.height * 0.45; // Tunable value

                    if (distanceToHitPointUpward < upwardCorrectionTriggerDistance) {
                        // Player is embedded. Snap them so their feet are on this "ceiling" surface.
                        const snapOffset = 0.01; // Consistent snap offset
                        player.position.copy(hitPointUpward.clone().add(playerUp.clone().multiplyScalar(player.height * 0.5 + snapOffset)));
                        
                        player.onGround = true; // Consider them grounded now

                        // Nullify any strong downward velocity component that pushed them through
                        const verticalVelocityScalar = player.velocity.dot(playerUp);
                        if (verticalVelocityScalar < -0.01) { // If moving "down" (towards planet center) significantly
                            const downwardVelocityComponent = playerUp.clone().multiplyScalar(verticalVelocityScalar);
                            player.velocity.sub(downwardVelocityComponent); // Remove this component
                        }
                    }
                }
            }

            // Update player position based on velocity
            player.position.add(player.velocity);

            // Update camera position to player's head
            camera.position.copy(player.position);

            updatePlayerDebugMesh();
            renderer.render(scene, camera); // Single render call at the end of animate
        }

        /**
         * Updates the position and orientation of the player's debug mesh.
         */
        function updatePlayerDebugMesh() {
            if (!playerDebugMesh) return;

            playerDebugMesh.position.copy(player.position);

            // Orient the debug mesh:
            // 1. Make its local Y-axis point away from the planet's center (playerUp).
            // 2. Rotate it around this local Y-axis to match the player's yaw.
            const playerUp = player.position.clone().normalize();
            const yAxis = new THREE.Vector3(0, 1, 0); // Standard Y-axis

            // Set the initial upright orientation based on playerUp
            playerDebugMesh.quaternion.setFromUnitVectors(yAxis, playerUp);

            // Apply the player's yaw rotation around their current local "up" axis (which is playerUp)
            playerDebugMesh.rotateOnAxis(playerUp, player.rotation.yaw);
        }

        // Initialize the game when the window loads
        window.onload = function() {
            init();
            animate();
        };

        // Event listener for mining (desktop only for now)
        document.addEventListener('click', (event) => {
            if (isLocked) { // Only allow mining if pointer is locked (desktop mode)
                mineBlockAtCrosshair();
            }
        });
    </script>
</body>
</html>
