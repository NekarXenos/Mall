<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Marching Cubes Planet Miner (FPS) with Building</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e;
            color: #e0e0e0;
            -webkit-user-select: none;
            user-select: none;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #message-box {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 10px;
            color: #fff;
            font-size: 1.2em;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            z-index: 100;
        }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 200;
            color: white;
            font-size: 2em;
            cursor: pointer;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin-left: -10px;
            margin-top: -10px;
            border: 2px solid white;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.2);
            z-index: 100;
        }
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 150;
            pointer-events: none; /* Allows clicks to pass through if not on buttons */
        }
        #joystick-area, #action-buttons-area {
            pointer-events: auto; /* Re-enable pointer events for controls */
            display: flex;
            align-items: center;
            gap: 10px; /* Space between buttons */
        }
        #joystick-base {
            width: 100px;
            height: 100px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            touch-action: none; /* Prevent browser default touch actions */
        }
        #joystick-thumb {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            touch-action: none;
        }
        .action-button {
            background-color: #007bff; /* Blue button */
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1.2em;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: background-color 0.2s ease-in-out;
        }
        .action-button:active {
            background-color: #0056b3; /* Darker blue on click */
        }

        /* Styles copied from fibonacci_Craft_game.html */
        #game-info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(31, 41, 55, 0.8);
            padding: 16px 24px;
            border-radius: 12px;
            display: flex;
            gap: 24px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border: 1px solid rgba(75, 85, 99, 0.5);
            z-index: 10; /* Ensure info is above the canvas */
            align-items: center;
            justify-content: center;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }
        #inventory-display {
            min-width: 120px;
            text-align: center;
            font-weight: 600;
            background-color: #374151;
            padding: 8px 12px;
            border-radius: 8px;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
        }
        #block-inventory-count {
            font-size: 1.2em;
            color: #facc15; /* Highlight numbers */
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            #game-info {
                flex-direction: column;
                gap: 12px;
                padding: 12px 16px;
            }
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-FWN6NL8B16"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-FWN6NL8B16');
</script>
<body>
    <div style="position: absolute; top: 10px; left: 10px; z-index: 999;">
        <a href="../Arcade.html" style="color: white; text-decoration: none; background-color: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 5px;">Back to Arcade</a>
    </div>

    <!-- Game Info / Inventory Display -->
    <div id="game-info">
        <div id="inventory-display">
            Blocks: <span id="block-inventory-count">0</span>
        </div>
    </div>

    <div id="message-box">Click or tap to play!</div>
    <div id="overlay">Click to start</div>
    <div id="crosshair"></div>

    <div id="mobile-controls">
        <div id="joystick-area">
            <div id="joystick-base">
                <div id="joystick-thumb"></div>
            </div>
        </div>
        <div id="action-buttons-area">
            <button id="mine-button" class="action-button">MINE</button>
            <button id="build-button" class="action-button">BUILD</button>
        </div>
    </div>

    <script type="module">
        // Lookup Tables for Marching Cubes (copied from MarchingCubes.js for self-containment)
        const EdgeVertexIndices = [
            [0, 1], [1, 3], [3, 2], [2, 0], [4, 5], [5, 7], [7, 6], [6, 4],
            [0, 4], [1, 5], [3, 7], [2, 6],
        ];

        const EdgeMasks = [
            0x0, 0x109, 0x203, 0x30a, 0x80c, 0x905, 0xa0f, 0xb06,
            0x406, 0x50f, 0x605, 0x70c, 0xc0a, 0xd03, 0xe09, 0xf00,
            0x190, 0x99, 0x393, 0x29a, 0x99c, 0x895, 0xb9f, 0xa96,
            0x596, 0x49f, 0x795, 0x69c, 0xd9a, 0xc93, 0xf99, 0xe90,
            0x230, 0x339, 0x33, 0x13a, 0xa3c, 0xb35, 0x83f, 0x936,
            0x636, 0x73f, 0x435, 0x53c, 0xe3a, 0xf33, 0xc39, 0xd30,
            0x3a0, 0x2a9, 0x1a3, 0xaa, 0xbac, 0xaa5, 0x9af, 0x8a6,
            0x7a6, 0x6af, 0x5a5, 0x4ac, 0xfaa, 0xea3, 0xda9, 0xca0,
            0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc, 0x1c5, 0x2cf, 0x3c6,
            0xcc6, 0xdcf, 0xec5, 0xfcc, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
            0x950, 0x859, 0xb53, 0xa5a, 0x15c, 0x55, 0x35f, 0x256,
            0xd56, 0xc5f, 0xf55, 0xe5c, 0x55a, 0x453, 0x759, 0x650,
            0xaf0, 0xbf9, 0x8f3, 0x9fa, 0x2fc, 0x3f5, 0xff, 0x1f6,
            0xef6, 0xfff, 0xcf5, 0xdfc, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
            0xb60, 0xa69, 0x963, 0x86a, 0x36c, 0x265, 0x16f, 0x66,
            0xf66, 0xe6f, 0xd65, 0xc6c, 0x76a, 0x663, 0x569, 0x460,
            0x460, 0x569, 0x663, 0x76a, 0xc6c, 0xd65, 0xe6f, 0xf66,
            0x66, 0x16f, 0x265, 0x36c, 0x86a, 0x963, 0xa69, 0xb60,
            0x5f0, 0x4f9, 0x7f3, 0x6fa, 0xdfc, 0xcf5, 0xfff, 0xef6,
            0x1f6, 0xff, 0x3f5, 0x2fc, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
            0x650, 0x759, 0x453, 0x55a, 0xe5c, 0xf55, 0xc5f, 0xd56,
            0x256, 0x35f, 0x55, 0x15c, 0xa5a, 0xb53, 0x859, 0x950,
            0x7c0, 0x6c9, 0x5c3, 0x4ca, 0xfcc, 0xec5, 0xdcf, 0xcc6,
            0x3c6, 0x2cf, 0x1c5, 0xcc, 0xbca, 0xac3, 0x9c9, 0x8c0,
            0xca0, 0xda9, 0xea3, 0xfaa, 0x4ac, 0x5a5, 0x6af, 0x7a6,
            0x8a6, 0x9af, 0xaa5, 0xbac, 0xaa, 0x1a3, 0x2a9, 0x3a0,
            0xd30, 0xc39, 0xf33, 0xe3a, 0x53c, 0x435, 0x73f, 0x636,
            0x936, 0x83f, 0xb35, 0xa3c, 0x13a, 0x33, 0x339, 0x230,
            0xe90, 0xf99, 0xc93, 0xd9a, 0x69c, 0x795, 0x49f, 0x596,
            0xa96, 0xb9f, 0x895, 0x99c, 0x29a, 0x393, 0x99, 0x190,
            0xf00, 0xe09, 0xd03, 0xc0a, 0x70c, 0x605, 0x50f, 0x406,
            0xb06, 0xa0f, 0x905, 0x80c, 0x30a, 0x203, 0x109, 0x0,
        ];

        const TriangleTable = [
            [ -1 ],
            [ 0, 3, 8, -1 ], [ 0, 9, 1, -1 ], [ 3, 8, 1, 1, 8, 9, -1 ],
            [ 2, 11, 3, -1 ], [ 8, 0, 11, 11, 0, 2, -1 ], [ 3, 2, 11, 1, 0, 9, -1 ],
            [ 11, 1, 2, 11, 9, 1, 11, 8, 9, -1 ], [ 1, 10, 2, -1 ],
            [ 0, 3, 8, 2, 1, 10, -1 ], [ 10, 2, 9, 9, 2, 0, -1 ],
            [ 8, 2, 3, 8, 10, 2, 8, 9, 10, -1 ], [ 11, 3, 10, 10, 3, 1, -1 ],
            [ 10, 0, 1, 10, 8, 0, 10, 11, 8, -1 ],
            [ 9, 3, 0, 9, 11, 3, 9, 10, 11, -1 ], [ 8, 9, 11, 11, 9, 10, -1 ],
            [ 4, 8, 7, -1 ], [ 7, 4, 3, 3, 4, 0, -1 ], [ 4, 8, 7, 0, 9, 1, -1 ],
            [ 1, 4, 9, 1, 7, 4, 1, 3, 7, -1 ], [ 8, 7, 4, 11, 3, 2, -1 ],
            [ 4, 11, 7, 4, 2, 11, 4, 0, 2, -1 ],
            [ 0, 9, 1, 8, 7, 4, 11, 3, 2, -1 ],
            [ 7, 4, 11, 11, 4, 2, 2, 4, 9, 2, 9, 1, -1 ],
            [ 4, 8, 7, 2, 1, 10, -1 ],
            [ 7, 4, 3, 3, 4, 0, 10, 2, 1, -1 ],
            [ 10, 2, 9, 9, 2, 0, 7, 4, 8, -1 ],
            [ 10, 2, 3, 10, 3, 4, 3, 7, 4, 9, 10, 4, -1 ],
            [ 1, 10, 3, 3, 10, 11, 4, 8, 7, -1 ],
            [ 10, 11, 1, 11, 7, 4, 1, 11, 4, 1, 4, 0, -1 ],
            [ 7, 4, 8, 9, 3, 0, 9, 11, 3, 9, 10, 11, -1 ],
            [ 7, 4, 11, 4, 9, 11, 9, 10, 11, -1 ],
            [ 9, 4, 5, -1 ], [ 9, 4, 5, 8, 0, 3, -1 ], [ 4, 5, 0, 0, 5, 1, -1 ],
            [ 5, 8, 4, 5, 3, 8, 5, 1, 3, -1 ], [ 9, 4, 5, 11, 3, 2, -1 ],
            [ 2, 11, 0, 0, 11, 8, 5, 9, 4, -1 ],
            [ 4, 5, 0, 0, 5, 1, 11, 3, 2, -1 ],
            [ 5, 1, 4, 1, 2, 11, 4, 1, 11, 4, 11, 8, -1 ],
            [ 1, 10, 2, 5, 9, 4, -1 ],
            [ 9, 4, 5, 0, 3, 8, 2, 1, 10, -1 ],
            [ 2, 5, 10, 2, 4, 5, 2, 0, 4, -1 ],
            [ 10, 2, 5, 5, 2, 4, 4, 2, 3, 4, 3, 8, -1 ],
            [ 11, 3, 10, 10, 3, 1, 4, 5, 9, -1 ],
            [ 4, 5, 9, 10, 0, 1, 10, 8, 0, 10, 11, 8, -1 ],
            [ 11, 3, 0, 11, 0, 5, 0, 4, 5, 10, 11, 5, -1 ],
            [ 4, 5, 8, 5, 10, 8, 10, 11, 8, -1 ],
            [ 8, 7, 9, 9, 7, 5, -1 ],
            [ 3, 9, 0, 3, 5, 9, 3, 7, 5, -1 ],
            [ 7, 0, 8, 7, 1, 0, 7, 5, 1, -1 ],
            [ 7, 5, 3, 3, 5, 1, -1 ],
            [ 5, 9, 7, 7, 9, 8, 2, 11, 3, -1 ],
            [ 2, 11, 7, 2, 7, 9, 7, 5, 9, 0, 2, 9, -1 ],
            [ 2, 11, 3, 7, 0, 8, 7, 1, 0, 7, 5, 1, -1 ],
            [ 2, 11, 1, 11, 7, 1, 7, 5, 1, -1 ],
            [ 8, 7, 9, 9, 7, 5, 2, 1, 10, -1 ],
            [ 10, 2, 1, 3, 9, 0, 3, 5, 9, 3, 7, 5, -1 ],
            [ 7, 5, 8, 5, 10, 2, 8, 5, 2, 8, 2, 0, -1 ],
            [ 10, 2, 5, 2, 3, 5, 3, 7, 5, -1 ],
            [ 8, 7, 5, 8, 5, 9, 11, 3, 10, 3, 1, 10, -1 ],
            [ 5, 11, 7, 10, 11, 5, 1, 9, 0, -1 ],
            [ 11, 5, 10, 7, 5, 11, 8, 3, 0, -1 ],
            [ 5, 11, 7, 10, 11, 5, -1 ],
            [ 6, 7, 11, -1 ], [ 7, 11, 6, 3, 8, 0, -1 ],
            [ 6, 7, 11, 0, 9, 1, -1 ],
            [ 9, 1, 8, 8, 1, 3, 6, 7, 11, -1 ],
            [ 3, 2, 7, 7, 2, 6, -1 ],
            [ 0, 7, 8, 0, 6, 7, 0, 2, 6, -1 ],
            [ 6, 7, 2, 2, 7, 3, 9, 1, 0, -1 ],
            [ 6, 7, 8, 6, 8, 1, 8, 9, 1, 2, 6, 1, -1 ],
            [ 11, 6, 7, 10, 2, 1, -1 ],
            [ 3, 8, 0, 11, 6, 7, 10, 2, 1, -1 ],
            [ 0, 9, 2, 2, 9, 10, 7, 11, 6, -1 ],
            [ 6, 7, 11, 8, 2, 3, 8, 10, 2, 8, 9, 10, -1 ],
            [ 7, 10, 6, 7, 1, 10, 7, 3, 1, -1 ],
            [ 8, 0, 7, 7, 0, 6, 6, 0, 1, 6, 1, 10, -1 ],
            [ 7, 3, 6, 3, 0, 9, 6, 3, 9, 6, 9, 10, -1 ],
            [ 6, 7, 10, 7, 8, 10, 8, 9, 10, -1 ],
            [ 11, 6, 8, 8, 6, 4, -1 ],
            [ 6, 3, 11, 6, 0, 3, 6, 4, 0, -1 ],
            [ 11, 6, 8, 8, 6, 4, 1, 0, 9, -1 ],
            [ 1, 3, 9, 3, 11, 6, 9, 3, 6, 9, 6, 4, -1 ],
            [ 2, 8, 3, 2, 4, 8, 2, 6, 4, -1 ], [ 4, 0, 6, 6, 0, 2, -1 ],
            [ 9, 1, 0, 2, 8, 3, 2, 4, 8, 2, 6, 4, -1 ],
            [ 9, 1, 4, 1, 2, 4, 2, 6, 4, -1 ],
            [ 4, 8, 6, 6, 8, 11, 1, 10, 2, -1 ],
            [ 1, 10, 2, 6, 3, 11, 6, 0, 3, 6, 4, 0, -1 ],
            [ 11, 6, 4, 11, 4, 8, 10, 2, 9, 2, 0, 9, -1 ],
            [ 10, 4, 9, 6, 4, 10, 11, 2, 3, -1 ],
            [ 4, 8, 3, 4, 3, 10, 3, 1, 10, 6, 4, 10, -1 ],
            [ 1, 10, 0, 10, 6, 0, 6, 4, 0, -1 ],
            [ 4, 10, 6, 9, 10, 4, 0, 8, 3, -1 ],
            [ 4, 10, 6, 9, 10, 4, -1 ],
            [ 6, 7, 11, 4, 5, 9, -1 ],
            [ 4, 5, 9, 7, 11, 6, 3, 8, 0, -1 ],
            [ 1, 0, 5, 5, 0, 4, 11, 6, 7, -1 ],
            [ 11, 6, 7, 5, 8, 4, 5, 3, 8, 5, 1, 3, -1 ],
            [ 3, 2, 7, 7, 2, 6, 9, 4, 5, -1 ],
            [ 5, 9, 4, 0, 7, 8, 0, 6, 7, 0, 2, 6, -1 ],
            [ 3, 2, 6, 3, 6, 7, 1, 0, 5, 0, 4, 5, -1 ],
            [ 6, 1, 2, 5, 1, 6, 4, 7, 8, -1 ],
            [ 10, 2, 1, 6, 7, 11, 4, 5, 9, -1 ],
            [ 0, 3, 8, 4, 5, 9, 11, 6, 7, 10, 2, 1, -1 ],
            [ 7, 11, 6, 2, 5, 10, 2, 4, 5, 2, 0, 4, -1 ],
            [ 8, 4, 7, 5, 10, 6, 3, 11, 2, -1 ],
            [ 9, 4, 5, 7, 10, 6, 7, 1, 10, 7, 3, 1, -1 ],
            [ 10, 6, 5, 7, 8, 4, 1, 9, 0, -1 ],
            [ 4, 3, 0, 7, 3, 4, 6, 5, 10, -1 ],
            [ 10, 6, 5, 8, 4, 7, -1 ],
            [ 9, 6, 5, 9, 11, 6, 9, 8, 11, -1 ],
            [ 11, 6, 3, 3, 6, 0, 0, 6, 5, 0, 5, 9, -1 ],
            [ 11, 6, 5, 11, 5, 0, 5, 1, 0, 8, 11, 0, -1 ],
            [ 11, 6, 3, 6, 5, 3, 5, 1, 3, -1 ],
            [ 9, 8, 5, 8, 3, 2, 5, 8, 2, 6, 5, 2, -1 ],
            [ 5, 9, 6, 9, 0, 6, 0, 2, 6, -1 ],
            [ 1, 6, 5, 2, 6, 1, 3, 0, 8, -1 ],
            [ 1, 6, 5, 2, 6, 1, -1 ],
            [ 2, 1, 10, 9, 6, 5, 9, 11, 6, 9, 8, 11, -1 ],
            [ 9, 0, 1, 3, 11, 2, 5, 10, 6, -1 ],
            [ 11, 0, 8, 2, 0, 11, 10, 6, 5, -1 ],
            [ 3, 11, 2, 5, 10, 6, -1 ],
            [ 1, 8, 3, 9, 8, 1, 5, 10, 6, -1 ],
            [ 6, 5, 10, 0, 1, 9, -1 ],
            [ 8, 3, 0, 5, 10, 6, -1 ],
            [ 6, 5, 10, -1 ],
            [ 10, 5, 6, -1 ], [ 0, 3, 8, 6, 10, 5, -1 ],
            [ 10, 5, 6, 9, 1, 0, -1 ],
            [ 3, 8, 1, 1, 8, 9, 6, 10, 5, -1 ],
            [ 2, 11, 3, 6, 10, 5, -1 ],
            [ 8, 0, 11, 11, 0, 2, 5, 6, 10, -1 ],
            [ 1, 0, 9, 2, 11, 3, 6, 10, 5, -1 ],
            [ 5, 6, 10, 11, 1, 2, 11, 9, 1, 11, 8, 9, -1 ],
            [ 5, 6, 1, 1, 6, 2, -1 ],
            [ 5, 6, 1, 1, 6, 2, 8, 0, 3, -1 ],
            [ 6, 9, 5, 6, 0, 9, 6, 2, 0, -1 ],
            [ 6, 2, 5, 2, 3, 8, 5, 2, 8, 5, 8, 9, -1 ],
            [ 3, 6, 11, 3, 5, 6, 3, 1, 5, -1 ],
            [ 8, 0, 1, 8, 1, 6, 1, 5, 6, 11, 8, 6, -1 ],
            [ 11, 3, 6, 6, 3, 5, 5, 3, 0, 5, 0, 9, -1 ],
            [ 5, 6, 9, 6, 11, 9, 11, 8, 9, -1 ],
            [ 5, 6, 10, 7, 4, 8, -1 ],
            [ 0, 3, 4, 4, 3, 7, 10, 5, 6, -1 ],
            [ 5, 6, 10, 4, 8, 7, 0, 9, 1, -1 ],
            [ 6, 10, 5, 1, 4, 9, 1, 7, 4, 1, 3, 7, -1 ],
            [ 7, 4, 8, 6, 10, 5, 2, 11, 3, -1 ],
            [ 10, 5, 6, 4, 11, 7, 4, 2, 11, 4, 0, 2, -1 ],
            [ 4, 8, 7, 6, 10, 5, 3, 2, 11, 1, 0, 9, -1 ],
            [ 1, 2, 10, 11, 7, 6, 9, 5, 4, -1 ],
            [ 2, 1, 6, 6, 1, 5, 8, 7, 4, -1 ],
            [ 0, 3, 7, 0, 7, 4, 2, 1, 6, 1, 5, 6, -1 ],
            [ 8, 7, 4, 6, 9, 5, 6, 0, 9, 6, 2, 0, -1 ],
            [ 7, 2, 3, 6, 2, 7, 5, 4, 9, -1 ],
            [ 4, 8, 7, 3, 6, 11, 3, 5, 6, 3, 1, 5, -1 ],
            [ 5, 0, 1, 4, 0, 5, 7, 6, 11, -1 ],
            [ 9, 5, 4, 6, 11, 7, 0, 8, 3, -1 ],
            [ 11, 7, 6, 9, 5, 4, -1 ],
            [ 6, 10, 4, 4, 10, 9, -1 ],
            [ 6, 10, 4, 4, 10, 9, 3, 8, 0, -1 ],
            [ 0, 10, 1, 0, 6, 10, 0, 4, 6, -1 ],
            [ 6, 10, 1, 6, 1, 8, 1, 3, 8, 4, 6, 8, -1 ],
            [ 9, 4, 10, 10, 4, 6, 3, 2, 11, -1 ],
            [ 2, 11, 8, 2, 8, 0, 6, 10, 4, 10, 9, 4, -1 ],
            [ 11, 3, 2, 0, 10, 1, 0, 6, 10, 0, 4, 6, -1 ],
            [ 6, 8, 4, 11, 8, 6, 2, 10, 1, -1 ],
            [ 4, 1, 9, 4, 2, 1, 4, 6, 2, -1 ],
            [ 3, 8, 0, 4, 1, 9, 4, 2, 1, 4, 6, 2, -1 ],
            [ 6, 2, 4, 4, 2, 0, -1 ],
            [ 3, 8, 2, 8, 4, 2, 4, 6, 2, -1 ],
            [ 4, 6, 9, 6, 11, 3, 9, 6, 3, 9, 3, 1, -1 ],
            [ 8, 6, 11, 4, 6, 8, 9, 0, 1, -1 ],
            [ 11, 3, 6, 3, 0, 6, 0, 4, 6, -1 ],
            [ 8, 6, 11, 4, 6, 8, -1 ],
            [ 10, 7, 6, 10, 8, 7, 10, 9, 8, -1 ],
            [ 3, 7, 0, 7, 6, 10, 0, 7, 10, 0, 10, 9, -1 ],
            [ 6, 10, 7, 7, 10, 8, 8, 10, 1, 8, 1, 0, -1 ],
            [ 6, 10, 7, 10, 1, 7, 1, 3, 7, -1 ],
            [ 3, 2, 11, 10, 7, 6, 10, 8, 7, 10, 9, 8, -1 ],
            [ 9, 2, 10, 0, 2, 9, 8, 4, 7, -1 ],
            [ 0, 8, 3, 7, 6, 11, 1, 2, 10, -1 ],
            [ 7, 6, 11, 1, 2, 10, -1 ],
            [ 2, 1, 9, 2, 9, 7, 9, 8, 7, 6, 2, 7, -1 ],
            [ 2, 7, 6, 3, 7, 2, 0, 1, 9, -1 ],
            [ 8, 7, 0, 7, 6, 0, 6, 2, 0, -1 ],
            [ 7, 2, 3, 6, 2, 7, -1 ],
            [ 8, 1, 9, 3, 1, 8, 11, 7, 6, -1 ],
            [ 11, 7, 6, 1, 9, 0, -1 ],
            [ 6, 11, 7, 0, 8, 3, -1 ],
            [ 11, 7, 6, -1 ],
            [ 7, 11, 5, 5, 11, 10, -1 ],
            [ 10, 5, 11, 11, 5, 7, 0, 3, 8, -1 ],
            [ 7, 11, 5, 5, 11, 10, 0, 9, 1, -1 ],
            [ 7, 11, 10, 7, 10, 5, 3, 8, 1, 8, 9, 1, -1 ],
            [ 5, 2, 10, 5, 3, 2, 5, 7, 3, -1 ],
            [ 5, 7, 10, 7, 8, 0, 10, 7, 0, 10, 0, 2, -1 ],
            [ 0, 9, 1, 5, 2, 10, 5, 3, 2, 5, 7, 3, -1 ],
            [ 9, 7, 8, 5, 7, 9, 10, 1, 2, -1 ],
            [ 1, 11, 2, 1, 7, 11, 1, 5, 7, -1 ],
            [ 8, 0, 3, 1, 11, 2, 1, 7, 11, 1, 5, 7, -1 ],
            [ 7, 11, 2, 7, 2, 9, 2, 0, 9, 5, 7, 9, -1 ],
            [ 7, 9, 5, 8, 9, 7, 3, 11, 2, -1 ],
            [ 3, 1, 7, 7, 1, 5, -1 ],
            [ 8, 0, 7, 0, 1, 7, 1, 5, 7, -1 ],
            [ 0, 9, 3, 9, 5, 3, 5, 7, 3, -1 ],
            [ 9, 7, 8, 5, 7, 9, -1 ],
            [ 8, 5, 4, 8, 10, 5, 8, 11, 10, -1 ],
            [ 0, 3, 11, 0, 11, 5, 11, 10, 5, 4, 0, 5, -1 ],
            [ 1, 0, 9, 8, 5, 4, 8, 10, 5, 8, 11, 10, -1 ],
            [ 10, 3, 11, 1, 3, 10, 9, 5, 4, -1 ],
            [ 3, 2, 8, 8, 2, 4, 4, 2, 10, 4, 10, 5, -1 ],
            [ 10, 5, 2, 5, 4, 2, 4, 0, 2, -1 ],
            [ 5, 4, 9, 8, 3, 0, 10, 1, 2, -1 ],
            [ 2, 10, 1, 4, 9, 5, -1 ],
            [ 8, 11, 4, 11, 2, 1, 4, 11, 1, 4, 1, 5, -1 ],
            [ 0, 5, 4, 1, 5, 0, 2, 3, 11, -1 ],
            [ 0, 11, 2, 8, 11, 0, 4, 9, 5, -1 ],
            [ 5, 4, 9, 2, 3, 11, -1 ],
            [ 4, 8, 5, 8, 3, 5, 3, 1, 5, -1 ],
            [ 0, 5, 4, 1, 5, 0, -1 ],
            [ 5, 4, 9, 3, 0, 8, -1 ],
            [ 5, 4, 9, -1 ],
            [ 11, 4, 7, 11, 9, 4, 11, 10, 9, -1 ],
            [ 0, 3, 8, 11, 4, 7, 11, 9, 4, 11, 10, 9, -1 ],
            [ 11, 10, 7, 10, 1, 0, 7, 10, 0, 7, 0, 4, -1 ],
            [ 3, 10, 1, 11, 10, 3, 7, 8, 4, -1 ],
            [ 3, 2, 10, 3, 10, 4, 10, 9, 4, 7, 3, 4, -1 ],
            [ 9, 2, 10, 0, 2, 9, 8, 4, 7, -1 ],
            [ 3, 4, 7, 0, 4, 3, 1, 2, 10, -1 ],
            [ 7, 8, 4, 10, 1, 2, -1 ],
            [ 7, 11, 4, 4, 11, 9, 9, 11, 2, 9, 2, 1, -1 ],
            [ 1, 9, 0, 4, 7, 8, 2, 3, 11, -1 ],
            [ 7, 11, 4, 11, 2, 4, 2, 0, 4, -1 ],
            [ 4, 7, 8, 2, 3, 11, -1 ],
            [ 9, 4, 1, 4, 7, 1, 7, 3, 1, -1 ],
            [ 7, 8, 4, 1, 9, 0, -1 ],
            [ 3, 4, 7, 0, 4, 3, -1 ],
            [ 7, 8, 4, -1 ],
            [ 11, 10, 8, 8, 10, 9, -1 ],
            [ 0, 3, 9, 3, 11, 9, 11, 10, 9, -1 ],
            [ 1, 0, 10, 0, 8, 10, 8, 11, 10, -1 ],
            [ 10, 3, 11, 1, 3, 10, -1 ],
            [ 3, 2, 8, 2, 10, 8, 10, 9, 8, -1 ],
            [ 9, 2, 10, 0, 2, 9, -1 ],
            [ 8, 3, 0, 10, 1, 2, -1 ],
            [ 2, 10, 1, -1 ],
            [ 2, 1, 11, 1, 9, 11, 9, 8, 11, -1 ],
            [ 11, 2, 3, 9, 0, 1, -1 ],
            [ 11, 0, 8, 2, 0, 11, -1 ],
            [ 3, 11, 2, -1 ],
            [ 1, 8, 3, 9, 8, 1, -1 ],
            [ 1, 9, 0, -1 ],
            [ 8, 3, 0, -1 ],
            [ -1 ],
        ];


        // Marching Cubes utility function
        function generateMarchingCubesGeometry(grid, threshold, gridSize, blockSize) {
            const vertices = [];
            const normals = [];
            const indices = [];
            const resolution = gridSize; // Marching Cubes operates on a grid

            // Function to get interpolated vertex position
            function interpolateVertex(p1, p2, val1, val2, threshold) {
                const mu = (threshold - val1) / (val2 - val1);
                return new THREE.Vector3(
                    p1.x + mu * (p2.x - p1.x),
                    p1.y + mu * (p2.y - p1.y),
                    p1.z + mu * (p2.z - p1.z)
                );
            }

            // Iterate over each cell in the grid
            for (let x = 0; x < resolution - 1; x++) {
                for (let y = 0; y < resolution - 1; y++) {
                    for (let z = 0; z < resolution - 1; z++) {
                        // Get the 8 corner values of the current cube
                        const cubeValues = new Array(8);
                        const cubeCorners = new Array(8); // Store actual 3D positions of corners

                        for (let i = 0; i < 8; i++) {
                            const x_offset = (i & 1) >> 0;
                            const y_offset = (i & 2) >> 1;
                            const z_offset = (i & 4) >> 2;

                            // Ensure we don't go out of bounds when accessing grid
                            const gx = x + x_offset;
                            const gy = y + y_offset;
                            const gz = z + z_offset;

                            // Handle boundary conditions for grid access
                            if (gx >= resolution || gy >= resolution || gz >= resolution) {
                                // This should ideally not happen with resolution - 1 loop limit,
                                // but as a safety for indexing cubeValues.
                                continue;
                            }

                            cubeValues[i] = grid[gx][gy][gz];
                            cubeCorners[i] = new THREE.Vector3(
                                (gx - gridSize / 2 + 0.5) * blockSize,
                                (gy - gridSize / 2 + 0.5) * blockSize,
                                (gz - gridSize / 2 + 0.5) * blockSize
                            );
                        }

                        // Determine the cube index from the thresholded values
                        let cubeIndex = 0;
                        if (cubeValues[0] < threshold) cubeIndex |= 1;
                        if (cubeValues[1] < threshold) cubeIndex |= 2;
                        if (cubeValues[2] < threshold) cubeIndex |= 4;
                        if (cubeValues[3] < threshold) cubeIndex |= 8;
                        if (cubeValues[4] < threshold) cubeIndex |= 16;
                        if (cubeValues[5] < threshold) cubeIndex |= 32;
                        if (cubeValues[6] < threshold) cubeIndex |= 64;
                        if (cubeValues[7] < threshold) cubeIndex |= 128;

                        // Get the triangulation case from TriangleTable
                        const triangles = TriangleTable[cubeIndex];

                        // Generate triangles
                        for (let i = 0; triangles[i] !== -1; i += 3) {
                            const edge1Index = triangles[i];
                            const edge2Index = triangles[i + 1];
                            const edge3Index = triangles[i + 2];

                            const v1a = EdgeVertexIndices[edge1Index][0];
                            const v1b = EdgeVertexIndices[edge1Index][1];
                            const v2a = EdgeVertexIndices[edge2Index][0];
                            const v2b = EdgeVertexIndices[edge2Index][1];
                            const v3a = EdgeVertexIndices[edge3Index][0];
                            const v3b = EdgeVertexIndices[edge3Index][1];

                            const p1 = interpolateVertex(cubeCorners[v1a], cubeCorners[v1b], cubeValues[v1a], cubeValues[v1b], threshold);
                            const p2 = interpolateVertex(cubeCorners[v2a], cubeCorners[v2b], cubeValues[v2a], cubeValues[v2b], threshold);
                            const p3 = interpolateVertex(cubeCorners[v3a], cubeCorners[v3b], cubeValues[v3a], cubeValues[v3b], threshold);

                            const currentVertexCount = vertices.length / 3;

                            vertices.push(p1.x, p1.y, p1.z);
                            vertices.push(p2.x, p2.y, p2.z);
                            vertices.push(p3.x, p3.y, p3.z);

                            indices.push(currentVertexCount, currentVertexCount + 1, currentVertexCount + 2);

                            // Calculate face normal
                            const cb = new THREE.Vector3().subVectors(p3, p2);
                            const ab = new THREE.Vector3().subVectors(p1, p2);
                            const normal = new THREE.Vector3().crossVectors(cb, ab).normalize();

                            normals.push(normal.x, normal.y, normal.z);
                            normals.push(normal.x, normal.y, normal.z);
                            normals.push(normal.x, normal.y, normal.z);
                        }
                    }
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3)); // For lighting calculations
            geometry.setIndex(indices);
            geometry.computeVertexNormals(); // Recalculate normals for smoother appearance

            return geometry;
        }

        // Set up basic Three.js scene components
        let scene, camera, renderer, raycaster;
        let marchingCubesMesh, marchingCubesMeshMoon; // Meshes for planet and moon
        let playerDebugMesh; // Visual representation of the player for debugging

        // --- Building-related Global Variables ---
        let blockInventory = 0; // Tracks the number of blocks in the player's inventory
        let cubes = []; // Array to store individual THREE.Mesh cube objects (built blocks)
        let cubeParent; // Group to hold all individual built cubes
        let cubeGeometry; // Geometry for individual built cubes
        let cubeMaterial; // Material for individual built cubes
        let blockInventoryCountSpan; // Reference to the HTML element for inventory display
        // --- End Building-related Global Variables ---

        // --- Player, Camera, and Controls ---
        let player; // A THREE.Group representing the player
        const clock = new THREE.Clock();
        const cameraOffset = new THREE.Vector3(0, 3, 8); // Third-person camera offset

        // Player settings, combining values from both files
        const playerSettings = {
            height: 1.75,
            speed: 5.0, // Units per second
            gravityStrength: 0.05, // 0.005, // Kept from PlanetMiner2 (per-frame acceleration)
            jumpStrength: 5, // 0.32, // Kept from PlanetMiner2 (per-jump impulse)
            sensitivity: 0.002 // Kept from PlanetMiner2
        };

        const keys = { w: false, a: false, s: false, d: false, space: false };
        const planetCenter = new THREE.Vector3(0, 0, 0);

        let isLocked = false;
        let mobileLookTouchId = -1;
        let mobileJoystickTouchId = -1;
        let joystickCenter = new THREE.Vector2();
        const joystickRadius = 50;

        // Voxel grid properties
        const GRID_SIZE = 100;
        const BLOCK_SIZE = 1;
        const PLANET_RADIUS_FACTOR = 0.8;
        const ISO_LEVEL = 0.5;

        // Moon properties
        const GRID_SIZE_MOON = 20;
        const MOON_RADIUS_FACTOR = 0.9;
        const MOON_ORBIT_DISTANCE = GRID_SIZE * BLOCK_SIZE * 0.75;

        let voxelData = [];
        let voxelDataMoon = [];
        let moonPosition = new THREE.Vector3();

        // DOM Elements
        const overlay = document.getElementById('overlay');
        const messageBox = document.getElementById('message-box');
        let canvas;
        const joystickBase = document.getElementById('joystick-base');
        const joystickThumb = document.getElementById('joystick-thumb');
        const mineButton = document.getElementById('mine-button');
        const buildButton = document.getElementById('build-button');
        const mobileControls = document.getElementById('mobile-controls');

        function updateInventoryDisplay() {
            if (blockInventoryCountSpan) {
                blockInventoryCountSpan.textContent = blockInventory;
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x282c34);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            canvas = renderer.domElement;

            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(5, 5, 5).normalize();
            scene.add(directionalLight);

            raycaster = new THREE.Raycaster();

            generatePlanet();
            generateMoon();

            cubeParent = new THREE.Group();
            scene.add(cubeParent);
            cubeGeometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            cubeMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00, roughness: 0.4, metalness: 0.2 });

            createPlayer(); // New function to create the player model

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('pointerlockchange', onPointerLockChange);

            overlay.addEventListener('click', () => {
                if (!isLocked) {
                    canvas.requestPointerLock();
                }
            });

            document.addEventListener('mousedown', onMouseDownDesktop);
            document.addEventListener('contextmenu', (event) => event.preventDefault());

            if (isMobileDevice()) {
                mobileControls.style.display = 'flex';
                setupMobileControls();
                messageBox.textContent = "Tap joystick to move, drag right side to look, tap buttons to interact!";
            } else {
                mobileControls.style.display = 'none';
                messageBox.textContent = "WASD: Move, Space: Jump, Mouse: Look, Click: Interact";
            }

            window.addEventListener('resize', onWindowResize);
            blockInventoryCountSpan = document.getElementById('block-inventory-count');
            updateInventoryDisplay();
        }

        function createPlayer() {
            player = new THREE.Group();
            // Attach state properties directly to the player group
            player.velocity = new THREE.Vector3();
            player.onGround = false;

            const bodyGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.5);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x5588ff });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            body.position.y = -0.3;
            player.add(body);

            const headGeometry = new THREE.DodecahedronGeometry(0.5, 0);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffccaa });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.castShadow = true;
            head.position.y = 0.8;
            player.add(head);
            player.head = head; // For easy access for camera logic

            // Initial position on the planet's surface
            const planetRadius = GRID_SIZE / 2 * BLOCK_SIZE * PLANET_RADIUS_FACTOR;
            player.position.set(0, planetRadius + playerSettings.height, 0);
            
            // Orient player to be upright at the start
            const initialUp = player.position.clone().normalize();
            player.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), initialUp);
            scene.add(player);
        }

        function onMouseDownDesktop(event) {
            if (!isLocked) return;
            if (event.button === 0) mineBlockAtCrosshair();
            else if (event.button === 2) placeBlockAtCrosshair();
        }

        function isMobileDevice() {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            return /android|iphone|ipad|ipod|blackberry|windows phone/i.test(userAgent) ||
                   ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        }

        function setupMobileControls() {
            joystickBase.addEventListener('touchstart', onJoystickStart, { passive: false });
            document.addEventListener('touchmove', onJoystickMove, { passive: false });
            document.addEventListener('touchend', onJoystickEnd, { passive: false });
            // Note: Mobile look controls are not implemented in this version.
            mineButton.addEventListener('click', mineBlockAtCrosshair);
            buildButton.addEventListener('click', placeBlockAtCrosshair);
        }

        function onJoystickStart(event) {
            event.preventDefault();
            if (mobileJoystickTouchId === -1) {
                const touch = event.changedTouches[0];
                const rect = joystickBase.getBoundingClientRect();
                joystickCenter.set(rect.left + rect.width / 2, rect.top + rect.height / 2);
                mobileJoystickTouchId = touch.identifier;
            }
        }

        function onJoystickMove(event) {
            event.preventDefault();
            for (let touch of event.changedTouches) {
                if (touch.identifier === mobileJoystickTouchId) {
                    let dx = touch.clientX - joystickCenter.x;
                    let dy = touch.clientY - joystickCenter.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > joystickRadius) {
                        dx *= joystickRadius / distance;
                        dy *= joystickRadius / distance;
                    }
                    joystickThumb.style.transform = `translate(${dx}px, ${dy}px)`;
                    keys.w = dy < -20;
                    keys.s = dy > 20;
                    keys.a = dx < -20;
                    keys.d = dx > 20;
                }
            }
        }

        function onJoystickEnd(event) {
            for (let touch of event.changedTouches) {
                if (touch.identifier === mobileJoystickTouchId) {
                    joystickThumb.style.transform = `translate(0, 0)`;
                    mobileJoystickTouchId = -1;
                    keys.w = keys.a = keys.s = keys.d = false;
                }
            }
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': keys.w = true; break;
                case 'KeyA': keys.a = true; break;
                case 'KeyS': keys.s = true; break;
                case 'KeyD': keys.d = true; break;
                case 'Space':
                    if (player && player.onGround) {
                        const upDirection = player.position.clone().normalize();
                        player.velocity.add(upDirection.multiplyScalar(playerSettings.jumpStrength));
                        player.onGround = false;
                    }
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': keys.w = false; break;
                case 'KeyA': keys.a = false; break;
                case 'KeyS': keys.s = false; break;
                case 'KeyD': keys.d = false; break;
                case 'Space': keys.space = false; break;
            }
        }

        function onMouseMove(event) {
            if (!isLocked || !player) return;
            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;

            const playerUp = player.position.clone().normalize();
            const yawDelta = -movementX * playerSettings.sensitivity;
            const yawQuaternion = new THREE.Quaternion().setFromAxisAngle(playerUp, yawDelta);
            player.quaternion.premultiply(yawQuaternion);

            const pitchDelta = -movementY * playerSettings.sensitivity;
            player.head.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.head.rotation.x + pitchDelta));
        }

        function onPointerLockChange() {
            if (document.pointerLockElement === canvas) {
                isLocked = true;
                overlay.style.display = 'none';
                messageBox.style.display = 'block';
                document.addEventListener('mousemove', onMouseMove, false);
            } else {
                isLocked = false;
                overlay.style.display = 'flex';
                messageBox.style.display = 'none';
                document.removeEventListener('mousemove', onMouseMove, false);
            }
        }

        function mineBlockAtCrosshair() {
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects([marchingCubesMesh, marchingCubesMeshMoon].filter(mesh => mesh).concat(cubes));
            if (intersects.length > 0) {
                const intersected = intersects[0];
                const intersectionPoint = intersected.point;
                const intersectedObject = intersected.object;
                const miningRayDir = raycaster.ray.direction;
                const offsetWorldPoint = intersectionPoint.clone().add(miningRayDir.clone().multiplyScalar(-BLOCK_SIZE * 0.25));

                if (intersectedObject === marchingCubesMesh) {
                    const halfGridPlanet = GRID_SIZE / 2;
                    const gridX = Math.floor(offsetWorldPoint.x / BLOCK_SIZE + halfGridPlanet);
                    const gridY = Math.floor(offsetWorldPoint.y / BLOCK_SIZE + halfGridPlanet);
                    const gridZ = Math.floor(offsetWorldPoint.z / BLOCK_SIZE + halfGridPlanet);
                    if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE && gridZ >= 0 && gridZ < GRID_SIZE) {
                        mineBlock(gridX, gridY, gridZ, 'planet', intersectionPoint);
                        blockInventory++;
                        updateInventoryDisplay();
                    }
                } else if (intersectedObject === marchingCubesMeshMoon) {
                    const localOffsetPointForMoon = offsetWorldPoint.clone().sub(marchingCubesMeshMoon.position);
                    const halfGridMoon = GRID_SIZE_MOON / 2;
                    const gridX = Math.floor(localOffsetPointForMoon.x / BLOCK_SIZE + halfGridMoon);
                    const gridY = Math.floor(localOffsetPointForMoon.y / BLOCK_SIZE + halfGridMoon);
                    const gridZ = Math.floor(localOffsetPointForMoon.z / BLOCK_SIZE + halfGridMoon);
                    if (gridX >= 0 && gridX < GRID_SIZE_MOON && gridY >= 0 && gridY < GRID_SIZE_MOON && gridZ >= 0 && gridZ < GRID_SIZE_MOON) {
                        mineBlock(gridX, gridY, gridZ, 'moon', intersectionPoint);
                        blockInventory++;
                        updateInventoryDisplay();
                    }
                } else if (cubes.includes(intersectedObject)) {
                    cubeParent.remove(intersectedObject);
                    cubes = cubes.filter(cube => cube.uuid !== intersectedObject.uuid);
                    intersectedObject.geometry.dispose();
                    intersectedObject.material.dispose();
                    blockInventory++;
                    updateInventoryDisplay();
                }
            }
        }

        function placeBlockAtCrosshair() {
            if (blockInventory <= 0) {
                messageBox.textContent = "No blocks to place!";
                setTimeout(() => { messageBox.textContent = "Controls active"; }, 1500);
                return;
            }
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const objectsToIntersect = [marchingCubesMesh, marchingCubesMeshMoon].filter(mesh => mesh).concat(cubes);
            const intersects = raycaster.intersectObjects(objectsToIntersect);
            if (intersects.length > 0) {
                const intersected = intersects[0];
                const hitPoint = intersected.point;
                const faceNormal = intersected.face.normal;
                const newPosition = hitPoint.clone().add(faceNormal.clone().multiplyScalar(BLOCK_SIZE / 2));
                
                const distanceToPlayer = newPosition.distanceTo(player.position);
                if (distanceToPlayer < BLOCK_SIZE) {
                    messageBox.textContent = "Cannot place block inside yourself!";
                    setTimeout(() => { messageBox.textContent = "Controls active"; }, 1500);
                    return;
                }

                const newCube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                newCube.position.copy(newPosition);
                newCube.lookAt(planetCenter);
                cubeParent.add(newCube);
                cubes.push(newCube);
                blockInventory--;
                updateInventoryDisplay();
            }
        }

        function generatePlanet() {
            for (let x = 0; x < GRID_SIZE; x++) {
                voxelData[x] = [];
                for (let y = 0; y < GRID_SIZE; y++) {
                    voxelData[x][y] = [];
                    for (let z = 0; z < GRID_SIZE; z++) {
                        const center = GRID_SIZE / 2;
                        const dx = (x - center + 0.5), dy = (y - center + 0.5), dz = (z - center + 0.5);
                        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        const normalizedDist = dist / (GRID_SIZE / 2 * PLANET_RADIUS_FACTOR);
                        voxelData[x][y][z] = Math.max(0, 1 - normalizedDist);
                    }
                }
            }
            updateMarchingCubesMesh();
        }

        function generateMoon() {
            const lightDirForMoonPlacement = new THREE.Vector3(1, 1, 1).normalize();
            moonPosition.copy(lightDirForMoonPlacement).negate().setLength(MOON_ORBIT_DISTANCE);
            for (let x = 0; x < GRID_SIZE_MOON; x++) {
                voxelDataMoon[x] = [];
                for (let y = 0; y < GRID_SIZE_MOON; y++) {
                    voxelDataMoon[x][y] = [];
                    for (let z = 0; z < GRID_SIZE_MOON; z++) {
                        const center = GRID_SIZE_MOON / 2;
                        const dx = (x - center + 0.5), dy = (y - center + 0.5), dz = (z - center + 0.5);
                        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        const normalizedDist = dist / (GRID_SIZE_MOON / 2 * MOON_RADIUS_FACTOR);
                        voxelDataMoon[x][y][z] = Math.max(0, 1 - normalizedDist);
                    }
                }
            }
            updateMarchingCubesMoonMesh();
        }

        function updateMarchingCubesMesh() {
            if (marchingCubesMesh) {
                scene.remove(marchingCubesMesh);
                marchingCubesMesh.geometry.dispose();
                marchingCubesMesh.material.dispose();
            }
            const geometry = generateMarchingCubesGeometry(voxelData, ISO_LEVEL, GRID_SIZE, BLOCK_SIZE);
            const material = new THREE.MeshStandardMaterial({ color: 0x5a2d0a, roughness: 0.7, metalness: 0.2, side: THREE.DoubleSide });
            marchingCubesMesh = new THREE.Mesh(geometry, material);
            scene.add(marchingCubesMesh);
        }

        function updateMarchingCubesMoonMesh() {
            if (marchingCubesMeshMoon) {
                scene.remove(marchingCubesMeshMoon);
                if (marchingCubesMeshMoon.geometry) marchingCubesMeshMoon.geometry.dispose();
                if (marchingCubesMeshMoon.material) marchingCubesMeshMoon.material.dispose();
            }
            const geometry = generateMarchingCubesGeometry(voxelDataMoon, ISO_LEVEL, GRID_SIZE_MOON, BLOCK_SIZE);
            const material = new THREE.MeshStandardMaterial({ color: 0xcccccc, emissive: 0x111133, roughness: 0.9, metalness: 0.1, side: THREE.DoubleSide });
            marchingCubesMeshMoon = new THREE.Mesh(geometry, material);
            marchingCubesMeshMoon.position.copy(moonPosition);
            scene.add(marchingCubesMeshMoon);
            const moonLight = new THREE.PointLight(0x6080ff, 0.6, MOON_ORBIT_DISTANCE * 1.2, 1.5);
            marchingCubesMeshMoon.add(moonLight);
        }

        function mineBlock(gridX, gridY, gridZ, targetType, effectWorldPosition) {
            if (targetType === 'planet') {
                voxelData[gridX][gridY][gridZ] = 0;
                updateMarchingCubesMesh();
            } else if (targetType === 'moon') {
                voxelDataMoon[gridX][gridY][gridZ] = 0;
                updateMarchingCubesMoonMesh();
            }
            createMiningEffect(effectWorldPosition, targetType);
        }

        function createMiningEffect(position, minedObjectType) {
            // Visual effects logic remains the same...
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (isMobileDevice()) {
                const rect = joystickBase.getBoundingClientRect();
                joystickCenter.set(rect.left + rect.width / 2, rect.top + rect.height / 2);
            }
        }

        function updateCamera() {
            if (!player) return;
            camera.up.copy(player.position).normalize();
            const headPosition = new THREE.Vector3();
            player.head.getWorldPosition(headPosition);
            const headQuaternion = new THREE.Quaternion();
            player.head.getWorldQuaternion(headQuaternion);
            const offsetFromHead = cameraOffset.clone();
            offsetFromHead.y -= player.head.position.y;
            const cameraOffsetRotated = offsetFromHead.clone().applyQuaternion(headQuaternion);
            const desiredCameraPosition = headPosition.clone().add(cameraOffsetRotated);
            camera.position.lerp(desiredCameraPosition, 0.15);
            camera.lookAt(headPosition);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (isLocked && player) {
                // --- Player Update Logic ---
                const playerUp = player.position.clone().normalize();
                const gravityDirection = planetCenter.clone().sub(player.position).normalize();

                // 1. Apply gravity
                if (!player.onGround) {
                    player.velocity.add(gravityDirection.multiplyScalar(playerSettings.gravityStrength));
                }

                // 2. Get movement input and project onto tangent plane
                const moveDirection = new THREE.Vector3();
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(player.quaternion);
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(player.quaternion);
                if (keys.w) moveDirection.add(forward);
                if (keys.s) moveDirection.sub(forward);
                if (keys.a) moveDirection.add(right.clone().multiplyScalar(-1));
                if (keys.d) moveDirection.add(right);

                const verticalComponent = player.velocity.clone().projectOnVector(playerUp);
                const horizontalComponent = player.velocity.clone().sub(verticalComponent);

                if (moveDirection.lengthSq() > 0) {
                    const projectedMove = moveDirection.projectOnPlane(playerUp).normalize();
                    const targetVelocity = projectedMove.multiplyScalar(playerSettings.speed);
                    horizontalComponent.lerp(targetVelocity, 0.2);
                } else {
                    horizontalComponent.lerp(new THREE.Vector3(), 0.1);
                }
                player.velocity.copy(horizontalComponent).add(verticalComponent);

                // 3. Update position based on velocity
                player.position.add(player.velocity.clone().multiplyScalar(delta));

                // 4. Collision detection and response (from original PlanetMiner2)
                const groundObjects = [marchingCubesMesh, marchingCubesMeshMoon].filter(mesh => mesh).concat(cubes);
                const rayOrigin = player.position.clone().add(playerUp.clone().multiplyScalar(-playerSettings.height * 0.5));
                raycaster.set(rayOrigin, gravityDirection);
                const intersects = raycaster.intersectObjects(groundObjects);

                player.onGround = false;
                if (intersects.length > 0) {
                    const hitPoint = intersects[0].point;
                    const distanceToHitPoint = rayOrigin.distanceTo(hitPoint);
                    const groundDetectionTolerance = 0.1;
                    const verticalSpeed = player.velocity.dot(playerUp);

                    if (distanceToHitPoint < groundDetectionTolerance && verticalSpeed < 0.05) {
                        player.onGround = true;
                        const snapOffset = 0.01;
                        player.position.copy(hitPoint.clone().add(playerUp.clone().multiplyScalar(playerSettings.height * 0.5 + snapOffset)));
                        const verticalVelocityComponent = playerUp.clone().multiplyScalar(player.velocity.dot(playerUp));
                        player.velocity.sub(verticalVelocityComponent);
                    }
                }
                
                // Upward collision correction
                if (!player.onGround && groundObjects.length > 0) {
                    const rayOriginUpward = player.position.clone();
                    raycaster.set(rayOriginUpward, playerUp);
                    const intersectsUpward = raycaster.intersectObjects(groundObjects);
                    if (intersectsUpward.length > 0 && intersectsUpward[0].distance < playerSettings.height * 0.5) {
                        const hitPointUpward = intersectsUpward[0].point;
                        player.position.copy(hitPointUpward.clone().add(playerUp.clone().multiplyScalar(playerSettings.height * 0.5 + 0.01)));
                        player.onGround = true;
                        const verticalVel = player.velocity.dot(playerUp);
                        if (verticalVel < 0) player.velocity.sub(playerUp.clone().multiplyScalar(verticalVel));
                    }
                }

                // 5. Orient player to stand upright on the sphere
                const playerCurrentUp = new THREE.Vector3(0, 1, 0).applyQuaternion(player.quaternion);
                const newUp = player.position.clone().normalize();
                const correction = new THREE.Quaternion().setFromUnitVectors(playerCurrentUp, newUp);
                player.quaternion.slerp(correction.multiply(player.quaternion), 0.2);
            }

            updateCamera();
            renderer.render(scene, camera);
        }

        // Initialize the game when the window loads
        window.onload = function() {
            init();
            animate();
        };
    </script>
</body>
</html>
