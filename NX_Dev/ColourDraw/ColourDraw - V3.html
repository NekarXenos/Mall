<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ColourDraw Vector Design App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        canvas {
            cursor: crosshair;
            touch-action: none;
        }
        .control-panel label {
            font-weight: 500;
        }
        .control-panel input[type="color"] {
            width: 40px;
            height: 40px;
            border: none;
            padding: 0;
            border-radius: 50%;
            cursor: pointer;
        }
        .control-panel input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        .control-panel input[type="color"]::-webkit-color-swatch {
            border: 1px solid #ddd;
            border-radius: 50%;
        }
        /* Message box styling */
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            text-align: center;
        }
        .message-box button {
            background-color: #3b82f6;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 15px;
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col md:flex-row h-screen overflow-hidden">

    <!-- Controls Panel -->
    <!-- Added min-w-64 to prevent the panel from becoming too narrow -->
    <div id="controls" class="control-panel w-full md:w-64 min-w-64 bg-white p-4 shadow-lg flex flex-col space-y-6 order-2 md:order-1 overflow-y-auto">
        <h1 class="text-xl font-bold text-gray-800">Controls</h1>
        
        <div class="space-y-2">
            <label for="fillColor" class="text-sm text-gray-600">Fill Color</label>
            <div class="flex items-center space-x-3">
                <input type="color" id="fillColor" value="#cccccc">
                <span id="fillColorValue" class="text-sm text-gray-500">#cccccc</span>
            </div>
        </div>

        <div class="space-y-2">
            <label for="strokeColor" class="text-sm text-gray-600">Stroke Color</label>
            <div class="flex items-center space-x-3">
                <input type="color" id="strokeColor" value="#000000">
                <span id="strokeColorValue" class="text-sm text-gray-500">#000000</span>
            </div>
        </div>

        <div class="space-y-2">
            <label for="strokeWidth" class="text-sm text-gray-600">Stroke Width: <span id="strokeWidthValue">2</span>px</label>
            <input type="range" id="strokeWidth" min="0" max="50" value="2" class="w-full">
        </div>

        <div class="flex flex-col space-y-3 pt-4 border-t">
            <button id="closePathBtn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Close Path</button>
            <button id="newShapeBtn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300">New Shape</button>
            <button id="clearBtn" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Clear Canvas</button>
        </div>

        <div class="pt-4 border-t mt-auto">
             <h2 class="text-lg font-semibold text-gray-700">Instructions</h2>
             <ul class="list-disc list-inside text-sm text-gray-600 mt-2 space-y-1">
                <li><b>Left-Click & Drag:</b> Create a point and drag to set its smooth handles.</li>
                <li><b>Right-Click & Drag:</b> Create a curve from the previous point.</li>
                <li><b>'New Shape'</b> starts another independent shape.</li>
                <li><b>Click a closed shape:</b> Selects it for move/rotate/scale.</li>
                <li><b>Drag a selected shape:</b> Moves it.</li>
                <li><b>Click selected shape again:</b> Toggles to rotate mode.</li>
                <li><b>Drag in rotate mode:</b> Rotates the shape.</li>
                <li><b>Drag corner handles:</b> Scales proportionally.</li>
                <li><b>Drag side handles:</b> Scales non-proportionally.</li>
                <li><b>Click outside a selected shape:</b> Deselects and allows drawing a new shape.</li>
             </ul>
        </div>
    </div>

    <!-- Canvas Area -->
    <div class="flex-1 bg-gray-200 order-1 md:order-2 flex items-center justify-center p-2">
        <canvas id="canvas"></canvas>
    </div>

    <script>
        // --- Setup ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const fillColorInput = document.getElementById('fillColor');
        const strokeColorInput = document.getElementById('strokeColor');
        const strokeWidthInput = document.getElementById('strokeWidth');
        const closePathBtn = document.getElementById('closePathBtn');
        const clearBtn = document.getElementById('clearBtn');
        const newShapeBtn = document.getElementById('newShapeBtn');
        const fillColorValue = document.getElementById('fillColorValue');
        const strokeColorValue = document.getElementById('strokeColorValue');
        const strokeWidthValue = document.getElementById('strokeWidthValue');

        // --- State Management ---
        let paths = []; // Stores all completed paths
        let currentPath = null; // The path currently being drawn

        // Drawing tool states (existing from original code)
        let isDrawing = false; // For right-click "Curve tool"
        let dragStartPoint = null; // For right-click "Curve tool"
        let isDraggingHandle = false; // For left-click "Pen tool" handle dragging
        let activePoint = null; // Point being modified by "Pen tool"

        // New states for selection, move, rotate, and scale
        let selectedPath = null; // The path currently selected for interaction
        let currentInteractionType = 'draw'; // 'draw', 'move', 'rotate', 'scale'
        let isInteracting = false; // True if actively moving, rotating, or scaling a selected path
        let lastMousePos = { x: 0, y: 0 }; // Last mouse position for delta calculation in move/rotate
        let rotationAnchor = { x: 0, y: 0 }; // For rotation calculations

        // Scaling specific states
        let isScaling = false;
        let activeScaleHandle = null; // 'nw', 'n', 'ne', 'e', 'se', 's', 'sw', 'w'
        let initialScaleMousePos = { x: 0, y: 0 };
        let initialScaleX = 1;
        let initialScaleY = 1;
        let initialPathWidth = 0; // Untransformed width for scaling ratio
        let initialPathHeight = 0; // Untransformed height for scaling ratio

        const HANDLE_SIZE = 10; // Size of scaling handles

        // --- Utility Functions ---
        
        /**
         * Shows a custom message box instead of alert.
         * @param {string} message The message to display.
         */
        function showMessageBox(message) {
            const messageBox = document.createElement('div');
            messageBox.className = 'message-box';
            messageBox.innerHTML = `
                <p>${message}</p>
                <button id="messageBoxOk">OK</button>
            `;
            document.body.appendChild(messageBox);

            document.getElementById('messageBoxOk').addEventListener('click', () => {
                document.body.removeChild(messageBox);
            });
        }

        /**
         * Resizes the canvas to fit its container and redraws the content.
         */
        function resizeCanvas() {
            const container = canvas.parentElement;
            const newWidth = container.clientWidth;
            const newHeight = container.clientHeight;

            if (canvas.width !== newWidth || canvas.height !== newHeight) {
                canvas.width = newWidth;
                canvas.height = newHeight;
                draw();
            }
        }

        /**
         * Gets mouse/touch position relative to the canvas.
         * @param {MouseEvent|TouchEvent} event The mouse or touch event.
         * @returns {{x: number, y: number}} The coordinates.
         */
        function getMousePos(event) {
            const rect = canvas.getBoundingClientRect();
            const clientX = event.clientX ?? (event.touches && event.touches[0] ? event.touches[0].clientX : (event.changedTouches ? event.changedTouches[0].clientX : 0));
            const clientY = event.clientY ?? (event.touches && event.touches[0] ? event.touches[0].clientY : (event.changedTouches ? event.changedTouches[0].clientY : 0));
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        /**
         * Creates a new path object, finalizing the previous one if it exists.
         */
        function createNewPath() {
            // If there's an active path with points, ensure it's finalized (closed) and added to paths.
            if (currentPath && currentPath.points.length > 0) {
                if (!currentPath.isClosed) {
                    currentPath.isClosed = true; // Implicitly close the path
                }
                if (!paths.includes(currentPath)) {
                   paths.push(currentPath);
                }
            }
            // Create a new empty path with default properties
            currentPath = {
                points: [],
                isClosed: false,
                fillColor: fillColorInput.value,
                strokeColor: strokeColorInput.value,
                strokeWidth: strokeWidthInput.value,
                translationX: 0, // Initial translation
                translationY: 0, // Initial translation
                rotation: 0, // Initial rotation in radians
                scaleX: 1,   // Initial scale
                scaleY: 1    // Initial scale
            };
            selectedPath = null; // Deselect any active path when starting new drawing
            currentInteractionType = 'draw';
        }

        /**
         * Calculates the centroid (average point) of a path's points.
         * Used as the center for rotation and scaling.
         * @param {object} path The path object.
         * @returns {{x: number, y: number}} The centroid coordinates.
         */
        function calculatePathCentroid(path) {
            if (path.points.length === 0) return { x: 0, y: 0 };
            let sumX = 0;
            let sumY = 0;
            path.points.forEach(p => {
                sumX += p.x;
                sumY += p.y;
            });
            return { x: sumX / path.points.length, y: sumY / path.points.length };
        }

        /**
         * Calculates the Euclidean distance between two points.
         * @param {{x: number, y: number}} p1 First point.
         * @param {{x: number, y: number}} p2 Second point.
         * @returns {number} The distance.
         */
        function dist(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }

        /**
         * Calculates the bounding box of a path's points and control points,
         * assuming no translation, rotation, or scaling (i.e., its intrinsic size).
         * @param {object} path The path object.
         * @returns {{minX: number, minY: number, maxX: number, maxY: number}} The untransformed bounding box.
         */
        function getUntransformedPathBounds(path) {
            if (path.points.length === 0) {
                return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
            }

            let minX = Infinity;
            let minY = Infinity;
            let maxX = -Infinity;
            let maxY = -Infinity;

            path.points.forEach(p => {
                minX = Math.min(minX, p.x, p.cp1.x, p.cp2.x);
                minY = Math.min(minY, p.y, p.cp1.y, p.cp2.y);
                maxX = Math.max(maxX, p.x, p.cp1.x, p.cp2.x);
                maxY = Math.max(maxY, p.y, p.cp1.y, p.cp2.y);
            });

            return { minX, minY, maxX, maxY };
        }

        /**
         * Transforms a local point (relative to path's untransformed centroid)
         * into canvas coordinates, applying the path's scale, rotation, and translation.
         * @param {{x: number, y: number}} point The local point.
         * @param {object} path The path object with transformations.
         * @returns {{x: number, y: number}} The transformed point in canvas coordinates.
         */
        function getTransformedPoint(point, path) {
            const centroid = calculatePathCentroid(path);
            let x = point.x - centroid.x;
            let y = point.y - centroid.y;

            // Apply scale
            x *= path.scaleX;
            y *= path.scaleY;

            // Apply rotation
            const cos = Math.cos(path.rotation);
            const sin = Math.sin(path.rotation);
            const rotatedX = x * cos - y * sin;
            const rotatedY = x * sin + y * cos;

            // Apply translation and translate back from centroid space
            return {
                x: rotatedX + centroid.x + path.translationX,
                y: rotatedY + centroid.y + path.translationY
            };
        }


        // --- Drawing Functions ---

        /**
         * Clears the canvas and redraws all paths, including current and selected.
         */
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Collect all paths to be drawn
            const allPaths = [...paths];
            if (currentPath && !allPaths.includes(currentPath)) {
                allPaths.push(currentPath);
            }

            // Draw each path
            allPaths.forEach(path => {
                drawPath(path);
            });
            
            // Draw handles for the current active drawing path (if not closed)
            if (currentPath && !currentPath.isClosed && currentInteractionType === 'draw') {
                drawHandles(currentPath);
            }

            // Draw selection outline and handles for the selected path
            if (selectedPath) {
                drawSelectionOutline(selectedPath);
            }
        }

        /**
         * Draws a single path with its fill, stroke, and applied transformations.
         * @param {object} path The path object to draw.
         */
        function drawPath(path) {
            if (path.points.length < 1) return;

            ctx.save(); // Save the current transformation state

            // Apply path-specific transformations (translation, rotation, scale)
            ctx.translate(path.translationX, path.translationY);
            const pathCentroid = calculatePathCentroid(path);
            ctx.translate(pathCentroid.x, pathCentroid.y);
            ctx.rotate(path.rotation);
            ctx.scale(path.scaleX, path.scaleY); // Apply scaling here
            ctx.translate(-pathCentroid.x, -pathCentroid.y);

            ctx.beginPath();
            ctx.moveTo(path.points[0].x, path.points[0].y);

            for (let i = 0; i < path.points.length - 1; i++) {
                const p1 = path.points[i];
                const p2 = path.points[i + 1];
                ctx.bezierCurveTo(p1.cp2.x, p1.cp2.y, p2.cp1.x, p2.cp1.y, p2.x, p2.y);
            }

            if (path.isClosed) {
                const pLast = path.points[path.points.length - 1];
                const pFirst = path.points[0];
                ctx.bezierCurveTo(pLast.cp2.x, pLast.cp2.y, pFirst.cp1.x, pFirst.cp1.y, pFirst.x, pFirst.y);
                ctx.closePath();
                ctx.fillStyle = path.fillColor;
                ctx.fill();
            }

            if (path.strokeWidth > 0) {
                ctx.strokeStyle = path.strokeColor;
                ctx.lineWidth = path.strokeWidth;
                ctx.stroke();
            }

            ctx.restore(); // Restore the previous transformation state
        }
        
        /**
         * Draws the control points and handles for the current drawing path.
         * @param {object} path The path object.
         */
        function drawHandles(path) {
            ctx.fillStyle = '#3b82f6'; // Blue-500
            path.points.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
                ctx.fill();
            });

            path.points.forEach(p => {
                ctx.beginPath();
                ctx.moveTo(p.cp1.x, p.cp1.y);
                ctx.lineTo(p.cp2.x, p.cp2.y);
                ctx.strokeStyle = '#f87171'; // Red-400
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.fillStyle = '#fca5a5'; // Red-300
                ctx.beginPath();
                ctx.arc(p.cp1.x, p.cp1.y, 4, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(p.cp2.x, p.cp2.y, 4, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        /**
         * Draws a dashed selection outline and rotation/scaling handles for the selected path.
         * @param {object} path The selected path object.
         */
        function drawSelectionOutline(path) {
            if (path.points.length === 0) return;

            ctx.save();
            // Apply path's own transformations to the context for correct bounding box and handle placement
            ctx.translate(path.translationX, path.translationY);
            const pathCentroid = calculatePathCentroid(path);
            ctx.translate(pathCentroid.x, pathCentroid.y);
            ctx.rotate(path.rotation);
            ctx.scale(path.scaleX, path.scaleY); // Apply scaling before getting bounds
            ctx.translate(-pathCentroid.x, -pathCentroid.y);

            // Calculate bounding box in the path's local (transformed) coordinate space
            // This min/max will be used for drawing handles relative to the visually scaled shape
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            path.points.forEach(p => {
                minX = Math.min(minX, p.x, p.cp1.x, p.cp2.x);
                minY = Math.min(minY, p.y, p.cp1.y, p.cp2.y);
                maxX = Math.max(maxX, p.x, p.cp1.x, p.cp2.x);
                maxY = Math.max(maxY, p.y, p.cp1.y, p.cp2.y);
            });

            const padding = 10;
            minX -= padding;
            minY -= padding;
            maxX += padding;
            maxY += padding;

            ctx.strokeStyle = '#34d399'; // Green-400
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]); // Dashed line
            ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);
            ctx.setLineDash([]); // Reset line dash

            // Draw rotation center handle
            if (currentInteractionType === 'rotate') {
                ctx.fillStyle = '#ef4444'; // Red-500
                ctx.beginPath();
                // Draw the rotation point at the path's centroid (which is the center of ctx.rotate)
                ctx.arc(pathCentroid.x, pathCentroid.y, 6, 0, 2 * Math.PI);
                ctx.fill();
                ctx.strokeStyle = '#dc2626';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Draw scaling handles
            ctx.fillStyle = '#60a5fa'; // Blue-400
            ctx.strokeStyle = '#3b82f6'; // Blue-500
            ctx.lineWidth = 1;

            const handlePositions = {
                'nw': { x: minX, y: minY },
                'n':  { x: minX + (maxX - minX) / 2, y: minY },
                'ne': { x: maxX, y: minY },
                'e':  { x: maxX, y: minY + (maxY - minY) / 2 },
                'se': { x: maxX, y: maxY },
                's':  { x: minX + (maxX - minX) / 2, y: maxY },
                'sw': { x: minX, y: maxY },
                'w':  { x: minX, y: minY + (maxY - minY) / 2 }
            };

            const handles = [];
            for (const type in handlePositions) {
                const p = handlePositions[type];
                ctx.beginPath();
                ctx.fillRect(p.x - HANDLE_SIZE / 2, p.y - HANDLE_SIZE / 2, HANDLE_SIZE, HANDLE_SIZE);
                ctx.strokeRect(p.x - HANDLE_SIZE / 2, p.y - HANDLE_SIZE / 2, HANDLE_SIZE, HANDLE_SIZE);
                // Store handle data for hit testing in canvas coordinates
                handles.push({ type: type, x: p.x, y: p.y, size: HANDLE_SIZE });
            }
            selectedPath.handles = handles; // Store handles on the selected path for hit testing later

            ctx.restore(); // Restore context state after drawing selection
        }


        // --- Event Handlers ---
        
        function handleMouseDown(e) {
            e.preventDefault();
            const pos = getMousePos(e);

            // Reset interaction flags at the start of every click
            isInteracting = false;
            isScaling = false; 
            activeScaleHandle = null;

            // 1. Check for scaling handle hit (highest priority, only if a path is selected)
            if (selectedPath && (e.button === 0 || e.type === 'touchstart')) {
                if (selectedPath.handles) {
                    for (const handle of selectedPath.handles) {
                        if (pos.x >= handle.x - handle.size / 2 && pos.x <= handle.x + handle.size / 2 &&
                            pos.y >= handle.y - handle.size / 2 && pos.y <= handle.y + handle.size / 2) {
                            
                            isScaling = true;
                            activeScaleHandle = handle.type;
                            initialScaleMousePos = pos;
                            initialScaleX = selectedPath.scaleX;
                            initialScaleY = selectedPath.scaleY;
                            const untransformedBounds = getUntransformedPathBounds(selectedPath);
                            initialPathWidth = (untransformedBounds.maxX - untransformedBounds.minX);
                            initialPathHeight = (untransformedBounds.maxY - untransformedBounds.minY);

                            if (initialPathWidth === 0) initialPathWidth = 1;
                            if (initialPathHeight === 0) initialPathHeight = 1;

                            isInteracting = true;
                            currentInteractionType = 'scale';
                            draw(); // Redraw immediately to show active handle
                            return; // Stop further processing
                        }
                    }
                }
            }

            // 2. Check for existing path hit (second priority)
            let hitPath = null;
            if (e.button === 0 || e.type === 'touchstart') {
                for (let i = paths.length - 1; i >= 0; i--) {
                    const path = paths[i];
                    if (path.isClosed) {
                        ctx.save();
                        ctx.translate(path.translationX, path.translationY);
                        const pathCentroid = calculatePathCentroid(path);
                        ctx.translate(pathCentroid.x, pathCentroid.y);
                        ctx.rotate(path.rotation);
                        ctx.scale(path.scaleX, path.scaleY);
                        ctx.translate(-pathCentroid.x, -pathCentroid.y);

                        ctx.beginPath();
                        ctx.moveTo(path.points[0].x, path.points[0].y);
                        for (let j = 0; j < path.points.length - 1; j++) {
                            const p1 = path.points[j];
                            const p2 = path.points[j + 1];
                            ctx.bezierCurveTo(p1.cp2.x, p1.cp2.y, p2.cp1.x, p2.cp1.y, p2.x, p2.y);
                        }
                        const pLast = path.points[path.points.length - 1];
                        const pFirst = path.points[0];
                        ctx.bezierCurveTo(pLast.cp2.x, pLast.cp2.y, pFirst.cp1.x, pFirst.cp1.y, pFirst.x, pFirst.y);
                        ctx.closePath();
                        const isHit = ctx.isPointInPath(pos.x, pos.y) || (path.strokeWidth > 0 && ctx.isPointInStroke(pos.x, pos.y));
                        ctx.restore();

                        if (isHit) {
                            hitPath = path;
                            break;
                        }
                    }
                }
            }

            if (hitPath) {
                if (selectedPath === hitPath) {
                    // If the same path is clicked again, toggle between move and rotate
                    currentInteractionType = (currentInteractionType === 'move' ? 'rotate' : 'move');
                } else {
                    // A new path is selected
                    selectedPath = hitPath;
                    currentInteractionType = 'move'; // Default to move
                    // Finalize any ongoing drawing if a new shape is selected
                    if (currentPath && !currentPath.isClosed && currentPath.points.length > 0) {
                        currentPath.isClosed = true;
                        if (!paths.includes(currentPath)) {
                           paths.push(currentPath);
                        }
                    }
                    currentPath = null; // No longer drawing current path
                }

                isInteracting = true;
                lastMousePos = pos;
                const pathCentroid = calculatePathCentroid(selectedPath);
                const invTransX = pos.x - selectedPath.translationX;
                const invTransY = pos.y - selectedPath.translationY;
                const angle = -selectedPath.rotation;
                const tempX = invTransX * Math.cos(angle) - invTransY * Math.sin(angle);
                const tempY = invTransX * Math.sin(angle) + invTransY * Math.cos(angle);
                rotationAnchor.x = tempX + selectedPath.translationX;
                rotationAnchor.y = tempY + selectedPath.translationY;

                draw();
                return; // Stop further processing
            }

            // 3. If neither handle nor path was hit, handle drawing or deselection
            // This block is only reached if no interaction with existing elements occurred.
            if (selectedPath) {
                // If a path was previously selected but we clicked outside, deselect it.
                selectedPath = null;
            }
            currentInteractionType = 'draw'; // Always switch to draw mode for new drawing

            // Existing drawing logic (for new shapes)
            if (e.button === 0 || e.type === 'touchstart') { // Left-click or Touch for pen tool
                if (!currentPath || currentPath.isClosed) {
                    createNewPath();
                }
                const newPoint = {
                    x: pos.x, y: pos.y,
                    cp1: { x: pos.x, y: pos.y },
                    cp2: { x: pos.x, y: pos.y }
                };
                currentPath.points.push(newPoint);
                isDraggingHandle = true;
                activePoint = newPoint;
            } else if (e.button === 2) { // Right-click for curve tool
                isDrawing = true;
                dragStartPoint = pos;
                if (!currentPath || currentPath.isClosed) {
                    createNewPath();
                }
            }
            draw();
        }

        function handleMouseMove(e) {
            e.preventDefault();
            const pos = getMousePos(e);

            if (isInteracting && selectedPath) {
                const dx = pos.x - lastMousePos.x;
                const dy = pos.y - lastMousePos.y;

                if (currentInteractionType === 'move') {
                    selectedPath.translationX += dx;
                    selectedPath.translationY += dy;
                } else if (currentInteractionType === 'rotate') {
                    // Calculate vectors from the rotation anchor (transformed to current canvas space)
                    // The rotationAnchor is in the original path's local space.
                    // We need to transform the rotationAnchor by the path's current translation.
                    const pathCentroid = calculatePathCentroid(selectedPath);
                    const transformedCentroid = getTransformedPoint(pathCentroid, {
                        ...selectedPath,
                        translationX: selectedPath.translationX,
                        translationY: selectedPath.translationY,
                        rotation: selectedPath.rotation,
                        scaleX: 1, // Use base scale for centroid reference
                        scaleY: 1
                    });
                    
                    const prevVecX = lastMousePos.x - transformedCentroid.x;
                    const prevVecY = lastMousePos.y - transformedCentroid.y;

                    const currVecX = pos.x - transformedCentroid.x;
                    const currVecY = pos.y - transformedCentroid.y;

                    const angle1 = Math.atan2(prevVecY, prevVecX);
                    const angle2 = Math.atan2(currVecY, currVecX);

                    const angleDelta = angle2 - angle1;
                    selectedPath.rotation += angleDelta;
                } else if (currentInteractionType === 'scale' && isScaling) {
                    let rotatedDx = dx;
                    let rotatedDy = dy;

                    // If the shape is rotated, de-rotate the mouse movement vector
                    // This aligns the mouse movement with the shape's local (unrotated) axes
                    if (selectedPath.rotation !== 0) {
                        const cos = Math.cos(-selectedPath.rotation); // De-rotate by negative current rotation
                        const sin = Math.sin(-selectedPath.rotation);
                        rotatedDx = dx * cos - dy * sin;
                        rotatedDy = dx * sin + dy * cos;
                    }

                    let newScaleX = selectedPath.scaleX;
                    let newScaleY = selectedPath.scaleY;

                    const minScale = 0.05; // Prevent scaling to very small or negative values

                    switch (activeScaleHandle) {
                        case 'nw': // Top-left corner
                        case 'se': // Bottom-right corner
                        case 'ne': // Top-right corner
                        case 'sw': { // Bottom-left corner
                            // For proportional scaling, base it on the overall distance change from the centroid.
                            // The 'dist' function naturally handles rotation as it works on canvas coordinates.
                            const centroid = calculatePathCentroid(selectedPath);
                            const transformedCentroid = getTransformedPoint(centroid, {
                                ...selectedPath,
                                translationX: selectedPath.translationX,
                                translationY: selectedPath.translationY,
                                rotation: selectedPath.rotation,
                                scaleX: 1, // Use base scale for centroid reference
                                scaleY: 1
                            });
                            const initialDistFromCentroid = dist(initialScaleMousePos, transformedCentroid);
                            const currentDistFromCentroid = dist(pos, transformedCentroid); // Use current mouse pos

                            if (initialDistFromCentroid > 0) {
                                const scaleRatio = currentDistFromCentroid / initialDistFromCentroid;
                                newScaleX = Math.max(minScale, initialScaleX * scaleRatio);
                                newScaleY = Math.max(minScale, initialScaleY * scaleRatio);
                            }
                            break;
                        }
                        case 'n': // Top side
                            // Scale vertically based on de-rotated dy
                            newScaleY = Math.max(minScale, initialScaleY * (1 - rotatedDy / initialPathHeight));
                            break;
                        case 's': // Bottom side
                            // Scale vertically based on de-rotated dy
                            newScaleY = Math.max(minScale, initialScaleY * (1 + rotatedDy / initialPathHeight));
                            break;
                        case 'e': // Right side
                            // Scale horizontally based on de-rotated dx
                            newScaleX = Math.max(minScale, initialScaleX * (1 + rotatedDx / initialPathWidth));
                            break;
                        case 'w': // Left side
                            // Scale horizontally based on de-rotated dx
                            newScaleX = Math.max(minScale, initialScaleX * (1 - rotatedDx / initialPathWidth));
                            break;
                    }
                    selectedPath.scaleX = newScaleX;
                    selectedPath.scaleY = newScaleY;
                }
                lastMousePos = pos; // Update last mouse position for next delta
                draw();
                return; // Interaction handled, do not proceed to drawing logic
            }

            // Existing drawing logic (only if currentInteractionType === 'draw')
            if (currentInteractionType === 'draw') {
                // Handle left-click "Pen Tool" handle dragging
                if (isDraggingHandle && activePoint) {
                    const dx = pos.x - activePoint.x;
                    const dy = pos.y - activePoint.y;

                    activePoint.cp2 = { x: pos.x, y: pos.y };
                    activePoint.cp1 = { x: activePoint.x - dx, y: activePoint.y - dy };
                    draw();
                }
                
                // Handle right-click "Curve Tool" preview
                if (isDrawing && dragStartPoint) {
                    draw(); // Redraw everything first
                    ctx.beginPath();
                    const lastPoint = currentPath.points.length > 0 ? currentPath.points[currentPath.points.length - 1] : dragStartPoint;
                    ctx.moveTo(lastPoint.x, lastPoint.y);
                    const currentPos = getMousePos(e);
                    ctx.bezierCurveTo(dragStartPoint.x, dragStartPoint.y, currentPos.x, currentPos.y, currentPos.x, currentPos.y);
                    ctx.strokeStyle = '#60a5fa';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }

        function handleMouseUp(e) {
            e.preventDefault();
            
            // If we were interacting (moving/rotating/scaling), stop interaction
            if (isInteracting) {
                isInteracting = false;
                isScaling = false; // Reset scaling specific flag
                activeScaleHandle = null; // Reset active handle
                draw();
                return; // Interaction handled, do not proceed to drawing logic
            }
            
            // Existing drawing logic (only if currentInteractionType === 'draw')
            if (currentInteractionType === 'draw') {
                // Handle right-click "Curve Tool" drawing
                if (isDrawing) {
                    const pos = getMousePos(e);
                    if (currentPath.points.length === 0) {
                        // If no points yet, add the first point at mouse up
                        const newPoint = { x: pos.x, y: pos.y, cp1: { x: pos.x, y: pos.y }, cp2: { x: pos.x, y: pos.y } };
                        currentPath.points.push(newPoint);
                    } else {
                        // For subsequent points, add new point and set control points
                        const prevPoint = currentPath.points[currentPath.points.length - 1];
                        const newPoint = { x: pos.x, y: pos.y, cp1: { x: pos.x, y: pos.y }, cp2: { x: pos.x, y: pos.y } };
                        if (dragStartPoint.x !== pos.x || dragStartPoint.y !== pos.y) {
                            const dx = pos.x - dragStartPoint.x;
                            const dy = pos.y - dragStartPoint.y;
                            prevPoint.cp2 = { x: dragStartPoint.x, y: dragStartPoint.y };
                            newPoint.cp1 = { x: pos.x - dx, y: pos.y - dy };
                        }
                        currentPath.points.push(newPoint);
                    }
                }

                // Reset all drawing tool-specific states
                isDrawing = false;
                dragStartPoint = null;
                isDraggingHandle = false;
                activePoint = null;
                draw();
            }
        }


        // --- Control Panel Listeners ---
        fillColorInput.addEventListener('input', (e) => {
            if (currentPath && currentInteractionType === 'draw') {
                currentPath.fillColor = e.target.value;
            } else if (selectedPath) {
                selectedPath.fillColor = e.target.value;
            }
            fillColorValue.textContent = e.target.value;
            draw();
        });

        strokeColorInput.addEventListener('input', (e) => {
            if (currentPath && currentInteractionType === 'draw') {
                currentPath.strokeColor = e.target.value;
            } else if (selectedPath) {
                selectedPath.strokeColor = e.target.value;
            }
            strokeColorValue.textContent = e.target.value;
            draw();
        });

        strokeWidthInput.addEventListener('input', (e) => {
            if (currentPath && currentInteractionType === 'draw') {
                currentPath.strokeWidth = e.target.value;
            } else if (selectedPath) {
                selectedPath.strokeWidth = e.target.value;
            }
            strokeWidthValue.textContent = e.target.value;
            draw();
        });

        closePathBtn.addEventListener('click', () => {
            if (currentPath && currentPath.points.length > 1) {
                currentPath.isClosed = true;
                if (!paths.includes(currentPath)) {
                   paths.push(currentPath);
                }
                currentPath = null; // No longer drawing, path is finalized
                selectedPath = null; // Deselect any existing selected path
                currentInteractionType = 'draw'; // Go back to drawing mode
                draw();
            } else if (currentPath && currentPath.points.length <= 1) {
                showMessageBox("Cannot close a path with less than two points.");
            }
        });

        clearBtn.addEventListener('click', () => {
            paths = [];
            currentPath = null;
            selectedPath = null;
            currentInteractionType = 'draw';
            draw();
        });

        newShapeBtn.addEventListener('click', () => {
            createNewPath(); // This also handles finalizing the previous currentPath
            draw();
        });


        // --- Initialisation ---
        window.addEventListener('resize', resizeCanvas);
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp); // End drawing if mouse leaves canvas
        canvas.addEventListener('mousemove', handleMouseMove);
        
        // Prevent right-click context menu
        canvas.addEventListener('contextmenu', e => e.preventDefault());
        
        // Touch events for mobile support
        canvas.addEventListener('touchstart', handleMouseDown, { passive: false });
        canvas.addEventListener('touchend', handleMouseUp, { passive: false });
        canvas.addEventListener('touchmove', handleMouseMove, { passive: false });


        // Initial setup
        resizeCanvas();
        createNewPath(); // Start with an empty path ready for drawing
        draw();
    </script>
</body>
</html>
